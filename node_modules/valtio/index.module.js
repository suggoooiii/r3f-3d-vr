import { useRef, useState, useEffect, useReducer, useCallback, useMemo, useLayoutEffect, useDebugValue } from 'react';
import { getUntrackedObject, markToTrack, isDeepChanged, createDeepProxy, affectedToPathList } from 'proxy-compare';

/*
export {
  unstable_createMutableSource as createMutableSource,
  unstable_useMutableSource as useMutableSource,
} from 'react'
*/
const TARGET = Symbol();
const GET_VERSION = Symbol();
const createMutableSource = (target, getVersion) => ({
  [TARGET]: target,
  [GET_VERSION]: getVersion
});
const useMutableSource = (source, getSnapshot, subscribe) => {
  const lastVersion = useRef(0);
  const currentVersion = source[GET_VERSION](source[TARGET]);
  const [state, setState] = useState(() => [
  /* [0] */
  source,
  /* [1] */
  getSnapshot,
  /* [2] */
  subscribe,
  /* [3] */
  currentVersion,
  /* [4] */
  getSnapshot(source[TARGET])]);
  let currentSnapshot = state[4];

  if (state[0] !== source || state[1] !== getSnapshot || state[2] !== subscribe || currentVersion !== state[3] && currentVersion !== lastVersion.current) {
    currentSnapshot = getSnapshot(source[TARGET]);
    setState([
    /* [0] */
    source,
    /* [1] */
    getSnapshot,
    /* [2] */
    subscribe,
    /* [3] */
    currentVersion,
    /* [4] */
    currentSnapshot]);
  }

  useEffect(() => {
    let didUnsubscribe = false;

    const checkForUpdates = () => {
      if (didUnsubscribe) {
        return;
      }

      try {
        const nextSnapshot = getSnapshot(source[TARGET]);
        const nextVersion = source[GET_VERSION](source[TARGET]);
        lastVersion.current = nextVersion;
        setState(prev => {
          if (prev[0] !== source || prev[1] !== getSnapshot || prev[2] !== subscribe) {
            return prev;
          }

          if (prev[4] === nextSnapshot) {
            return prev;
          }

          return [
          /* [0] */
          prev[0],
          /* [1] */
          prev[1],
          /* [2] */
          prev[2],
          /* [3] */
          nextVersion,
          /* [4] */
          nextSnapshot];
        });
      } catch (e) {
        // schedule update
        setState(prev => [...prev]);
      }
    };

    const unsubscribe = subscribe(source[TARGET], checkForUpdates);
    checkForUpdates();
    return () => {
      didUnsubscribe = true;
      unsubscribe();
    };
  }, [source, getSnapshot, subscribe]);
  return currentSnapshot;
};

const VERSION = Symbol();
const LISTENERS = Symbol();
const SNAPSHOT = Symbol();
const PROMISE_RESULT = Symbol();
const PROMISE_ERROR = Symbol();
const refSet = new WeakSet();
const ref = o => {
  refSet.add(o);
  return o;
};

const isSupportedObject = x => typeof x === 'object' && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);

const proxyCache = new WeakMap();
let globalVersion = 1;
const snapshotCache = new WeakMap();
const proxy = (initialObject = {}) => {
  if (!isSupportedObject(initialObject)) {
    throw new Error('unsupported object type');
  }

  if (proxyCache.has(initialObject)) {
    return proxyCache.get(initialObject);
  }

  let version = globalVersion;
  const listeners = new Set();

  const notifyUpdate = nextVersion => {
    if (!nextVersion) {
      nextVersion = ++globalVersion;
    }

    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach(listener => listener(nextVersion));
    }
  };

  const createSnapshot = (target, receiver) => {
    const cache = snapshotCache.get(receiver);

    if (cache && cache.version === version) {
      return cache.snapshot;
    }

    const snapshot = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    markToTrack(snapshot, true); // mark to track

    snapshotCache.set(receiver, {
      version,
      snapshot
    });
    Reflect.ownKeys(target).forEach(key => {
      const value = target[key];

      if (refSet.has(value)) {
        markToTrack(value, false); // mark not to track

        snapshot[key] = value;
      } else if (!isSupportedObject(value)) {
        snapshot[key] = value;
      } else if (value instanceof Promise) {
        if (PROMISE_RESULT in value) {
          snapshot[key] = value[PROMISE_RESULT];
        } else {
          const errorOrPromise = value[PROMISE_ERROR] || value;
          Object.defineProperty(snapshot, key, {
            get() {
              throw errorOrPromise;
            }

          });
        }
      } else if (value[VERSION]) {
        snapshot[key] = value[SNAPSHOT];
      } else {
        snapshot[key] = value;
      }
    });
    Object.freeze(snapshot);
    return snapshot;
  };

  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const proxyObject = new Proxy(baseObject, {
    get(target, prop, receiver) {
      if (prop === VERSION) {
        return version;
      }

      if (prop === LISTENERS) {
        return listeners;
      }

      if (prop === SNAPSHOT) {
        return createSnapshot(target, receiver);
      }

      return target[prop];
    },

    deleteProperty(target, prop) {
      const prevValue = target[prop];
      const childListeners = prevValue && prevValue[LISTENERS];

      if (childListeners) {
        childListeners.delete(notifyUpdate);
      }

      const deleted = Reflect.deleteProperty(target, prop);

      if (deleted) {
        notifyUpdate();
      }

      return deleted;
    },

    set(target, prop, value) {
      var _Object$getOwnPropert;

      const prevValue = target[prop];

      if (Object.is(prevValue, value)) {
        return true;
      }

      const childListeners = prevValue && prevValue[LISTENERS];

      if (childListeners) {
        childListeners.delete(notifyUpdate);
      }

      if (refSet.has(value) || !isSupportedObject(value) || (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(target, prop)) != null && _Object$getOwnPropert.set) {
        target[prop] = value;
      } else if (value instanceof Promise) {
        target[prop] = value.then(v => {
          target[prop][PROMISE_RESULT] = v;
          notifyUpdate();
        }).catch(e => {
          target[prop][PROMISE_ERROR] = e;
          notifyUpdate();
        });
      } else {
        value = getUntrackedObject(value) || value;

        if (value[LISTENERS]) {
          target[prop] = value;
        } else {
          target[prop] = proxy(value);
        }

        target[prop][LISTENERS].add(notifyUpdate);
      }

      notifyUpdate();
      return true;
    }

  });
  proxyCache.set(initialObject, proxyObject);
  Reflect.ownKeys(initialObject).forEach(key => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);

    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
};
const getVersion = proxyObject => {
  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!proxyObject || !proxyObject[VERSION])) {
    throw new Error('Please use proxy object');
  }

  return proxyObject[VERSION];
};
const subscribe = (proxyObject, callback, notifyInSync) => {
  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!proxyObject || !proxyObject[LISTENERS])) {
    throw new Error('Please use proxy object');
  }

  let pendingVersion = 0;

  const listener = nextVersion => {
    if (notifyInSync) {
      callback();
      return;
    }

    pendingVersion = nextVersion;
    Promise.resolve().then(() => {
      if (nextVersion === pendingVersion) {
        callback();
      }
    });
  };

  proxyObject[LISTENERS].add(listener);
  return () => {
    proxyObject[LISTENERS].delete(listener);
  };
};
const snapshot = proxyObject => {
  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!proxyObject || !proxyObject[SNAPSHOT])) {
    throw new Error('Please use proxy object');
  }

  return proxyObject[SNAPSHOT];
};

const isSSR = typeof window === 'undefined' || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent);
const useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect;

const useAffectedDebugValue = (state, affected) => {
  const pathList = useRef();
  useEffect(() => {
    pathList.current = affectedToPathList(state, affected);
  });
  useDebugValue(pathList.current);
};

const mutableSourceCache = new WeakMap();

const getMutableSource = proxyObject => {
  if (!mutableSourceCache.has(proxyObject)) {
    mutableSourceCache.set(proxyObject, createMutableSource(proxyObject, getVersion));
  }

  return mutableSourceCache.get(proxyObject);
};

const useProxy = (proxyObject, options) => {
  const [, forceUpdate] = useReducer(c => c + 1, 0);
  const affected = new WeakMap();
  const lastAffected = useRef();
  const prevSnapshot = useRef();
  const lastSnapshot = useRef();
  useIsomorphicLayoutEffect(() => {
    lastSnapshot.current = prevSnapshot.current = snapshot(proxyObject);
  }, [proxyObject]);
  useIsomorphicLayoutEffect(() => {
    lastAffected.current = affected;

    if (prevSnapshot.current !== lastSnapshot.current && isDeepChanged(prevSnapshot.current, lastSnapshot.current, affected, new WeakMap())) {
      prevSnapshot.current = lastSnapshot.current;
      forceUpdate();
    }
  });
  const notifyInSync = options == null ? void 0 : options.sync;
  const sub = useCallback((proxyObject, cb) => subscribe(proxyObject, () => {
    const nextSnapshot = snapshot(proxyObject);
    lastSnapshot.current = nextSnapshot;

    try {
      if (lastAffected.current && !isDeepChanged(prevSnapshot.current, nextSnapshot, lastAffected.current, new WeakMap())) {
        // not changed
        return;
      }
    } catch (e) {// ignore if a promise or something is thrown
    }

    prevSnapshot.current = nextSnapshot;
    cb();
  }, notifyInSync), [notifyInSync]);
  const currSnapshot = useMutableSource(getMutableSource(proxyObject), snapshot, sub);

  if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useAffectedDebugValue(currSnapshot, affected);
  }

  const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache

  return createDeepProxy(currSnapshot, affected, proxyCache);
};

export { proxy, ref, snapshot, subscribe, useProxy };
