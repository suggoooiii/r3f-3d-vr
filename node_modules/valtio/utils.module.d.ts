import type { NonPromise } from './vanilla';
/**
 * useLocalProxy
 *
 * This is to create a proxy in a component at mount.
 * and discard it when the component unmounts.
 * It returns a tuple of snapshot and state.
 *
 * [Notes]
 * Valtio is designed for module state and this use case for component states
 * is not a primary target. It might not be ideal for such use cases.
 * For component state, alternatively consider using
 * [useImmer](https://github.com/immerjs/use-immer).
 */
export declare const useLocalProxy: <T extends object>(init: T | (() => T)) => readonly [NonPromise<T>, T];
/**
 * subscribeKey
 *
 * The subscribeKey utility enables subscription to a primitive subproperty of a given state proxy.
 * Subscriptions created with subscribeKey will only fire when the specified property changes.
 *
 * @example
 * import { subscribeKey } from 'valtio/utils'
 * subscribeKey(state, 'count', (v) => console.log('state.count has changed to', v))
 */
export declare const subscribeKey: <T extends object>(proxyObject: T, key: keyof T, callback: (value: T[keyof T]) => void) => () => void;
/**
 * devtools
 *
 * This is to connect with [Redux DevTools Extension](https://github.com/zalmoxisus/redux-devtools-extension).
 * Limitation: Only plain objects/values are supported.
 *
 * @example
 * import { devtools } from 'valtio/utils'
 * const state = proxy({ count: 0, text: 'hello' })
 * const unsub = devtools(state, 'state name')
 */
export declare const devtools: <T extends object>(proxyObject: T, name?: string | undefined) => (() => void) | undefined;
/**
 * proxyWithComputed
 *
 * This is to create a proxy with initial object and additional object,
 * which specifies getters for computed values with dependency tracking.
 * It also accepts optional setters for computed values.
 *
 * [Notes]
 * This is for expert users and not recommended for ordinary users.
 * Contradictory to its name, this is costly and overlaps with useProxy.
 * Do not try to optimize too early. It can worsen the performance.
 * Measurement and comparison will be very important.
 *
 * @example
 * import { proxyWithComputed } from 'valtio/utils'
 * const state = proxyWithComputed({
 *   count: 1,
 * }, {
 *   doubled: snap => snap.count * 2, // getter only
 *   tripled: {
 *     get: snap => snap.count * 3,
 *     set: (state, newValue) => { state.count = newValue / 3 }
 *   }, // with optional setter
 * })
 */
export declare const proxyWithComputed: <T extends object, U extends object>(initialObject: T, computedFns: { [K in keyof U]: {
    get: (snap: NonPromise<T>) => U[K];
    set?: ((state: T, newValue: U[K]) => void) | undefined;
} | ((snap: NonPromise<T>) => U[K]); }) => T & U;
