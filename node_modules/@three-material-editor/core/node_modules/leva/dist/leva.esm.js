import { p as pick, s as styled, u as useInputContext, R as Row, L as Label, C as Chevron, c as createInternalPlugin, _ as _objectSpread2, o as omit, V as ValueInput, P as Portal, O as Overlay, a as Vector, g as getVectorPlugin, b as useTransform, d as useTh, e as _extends, m as multiplyStep, f as clamp, h as _objectWithoutProperties, n as normalizeKeyedNumberSettings, i as useDrag$1, j as invertedRange, k as sanitizeStep, r as range, l as RangeWrapper, q as Range, I as Indicator, S as Scrubber, t as SpecialInputTypes, w as warn, v as LevaErrors, x as updateInput, y as normalizeInput, z as StyledTitle, A as useValue, B as Plugins, D as log, E as InputContext, F as StyledInputWrapper$1, G as useCanvas2d, H as useInput, J as StyledWrapper, K as StyledContent, M as useStoreContext, N as StyledFolder, Q as StyledInputRow, T as debounce, U as PanelSettingsContext, W as StoreContext, X as mergeTheme, Y as ThemeContext, Z as register, $ as number$1 } from './vector-plugin-2bfe46a4.esm.js';
export { a0 as LevaStoreProvider, M as useStoreContext } from './vector-plugin-2bfe46a4.esm.js';
import v8n from 'v8n';
import React, { useRef, useMemo, useLayoutEffect, useEffect, useState, useCallback, forwardRef, useImperativeHandle } from 'react';
import '@radix-ui/react-portal';
import { dequal } from 'dequal/lite';
import tc from 'tinycolor2';
import { RgbaColorPicker, RgbColorPicker } from 'react-colorful';
import shallow from 'zustand/shallow';
import { useDrag } from 'react-use-gesture';
import 'clipboard-polyfill/text';
import '@radix-ui/react-tooltip';
import { useDropzone } from 'react-dropzone';
import create from 'zustand';
import ReactDOM from 'react-dom';
import merge from 'merge-value';
import '@stitches/react';

const join = (...args) => args.filter(Boolean).join('.');
function getKeyPath(path) {
  const dir = path.split('.');
  return [dir.pop(), dir.join('.') || undefined];
}

function getValuesForPaths(data, paths) {
  return Object.entries(pick(data, paths)).reduce((acc, [path, {
    value,
    disabled,
    key
  }]) => {
    acc[key] = disabled ? undefined : value;
    return acc;
  }, {});
}

function useCompareMemoize(value, deep) {
  const ref = useRef();
  const compare = deep ? dequal : shallow;

  if (!compare(value, ref.current)) {
    ref.current = value;
  }

  return ref.current;
}

function useDeepMemo(fn, deps) {
  return useMemo(fn, useCompareMemoize(deps, true));
}

function useToggle(toggled) {
  const wrapperRef = useRef(null);
  const contentRef = useRef(null);
  const firstRender = useRef(true);
  useLayoutEffect(() => {
    if (!toggled) {
      wrapperRef.current.style.height = '0px';
      wrapperRef.current.style.overflow = 'hidden';
    }
  }, []);
  useEffect(() => {
    if (firstRender.current) {
      firstRender.current = false;
      return;
    }

    let timeout;
    const ref = wrapperRef.current;

    const fixHeight = () => {
      if (toggled) {
        ref.style.removeProperty('height');
        ref.style.removeProperty('overflow');
        contentRef.current.scrollIntoView({
          behavior: 'smooth',
          block: 'nearest'
        });
      }
    };

    ref.addEventListener('transitionend', fixHeight, {
      once: true
    });
    const {
      height
    } = contentRef.current.getBoundingClientRect();
    ref.style.height = height + 'px';

    if (!toggled) {
      ref.style.overflow = 'hidden';
      timeout = window.setTimeout(() => ref.style.height = '0px', 50);
    }

    return () => {
      ref.removeEventListener('transitionend', fixHeight);
      clearTimeout(timeout);
    };
  }, [toggled]);
  return {
    wrapperRef,
    contentRef
  };
}

const useVisiblePaths = store => {
  const [paths, setPaths] = useState(store.getVisiblePaths());
  useEffect(() => {
    setPaths(store.getVisiblePaths());
    const unsub = store.useStore.subscribe(setPaths, store.getVisiblePaths, shallow);
    return () => unsub();
  }, [store]);
  return paths;
};

function useValuesForPath(store, paths, initialData) {
  const init = useRef(true);
  const valuesForPath = store.useStore(s => {
    const data = init.current ? initialData : s.data;
    return getValuesForPaths(data, paths);
  }, shallow);
  init.current = false;
  return valuesForPath;
}

function usePopin(margin = 3) {
  const popinRef = useRef(null);
  const wrapperRef = useRef(null);
  const [shown, setShow] = useState(false);
  const show = useCallback(() => setShow(true), []);
  const hide = useCallback(() => setShow(false), []);
  useLayoutEffect(() => {
    if (shown) {
      const {
        bottom,
        top,
        left
      } = popinRef.current.getBoundingClientRect();
      const {
        height
      } = wrapperRef.current.getBoundingClientRect();
      const direction = bottom + height > window.innerHeight - 40 ? 'up' : 'down';
      wrapperRef.current.style.position = 'fixed';
      wrapperRef.current.style.zIndex = '10000';
      wrapperRef.current.style.left = left + 'px';
      if (direction === 'down') wrapperRef.current.style.top = bottom + margin + 'px';else wrapperRef.current.style.bottom = window.innerHeight - top + margin + 'px';
    }
  }, [margin, shown]);
  return {
    popinRef,
    wrapperRef,
    shown,
    show,
    hide
  };
}

const schema$5 = (_o, s) => v8n().schema({
  options: v8n().passesAnyOf(v8n().object(), v8n().array())
}).test(s);
const normalize$4 = input => {
  let {
    value,
    options
  } = input;
  let keys;
  let values;

  if (Array.isArray(options)) {
    values = options;
    keys = options.map(String);
  } else {
    values = Object.values(options);
    keys = Object.keys(options);
  }

  if (!('value' in input)) value = values[0];else if (!values.includes(value)) {
    keys.unshift(String(value));
    values.unshift(value);
  }
  if (!Object.values(options).includes(value)) options[String(value)] = value;
  return {
    value,
    settings: {
      keys,
      values
    }
  };
};

var props$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  schema: schema$5,
  normalize: normalize$4
});

const SelectContainer = styled('div', {
  $leva__flexCenter: '',
  position: 'relative',
  '> svg': {
    pointerEvents: 'none',
    position: 'absolute',
    right: '$leva__md'
  }
});
const NativeSelect = styled('select', {
  position: 'absolute',
  top: 0,
  left: 0,
  width: '100%',
  height: '100%',
  opacity: 0
});
const PresentationalSelect = styled('div', {
  display: 'flex',
  alignItems: 'center',
  width: '100%',
  height: '$leva__rowHeight',
  backgroundColor: '$leva__elevation3',
  borderRadius: '$leva__sm',
  padding: '0 $leva__sm',
  cursor: 'pointer',
  [`${NativeSelect}:focus + &`]: {
    $leva__focusStyle: ''
  },
  [`${NativeSelect}:hover + &`]: {
    $leva__hoverStyle: ''
  }
});

function Select({
  displayValue,
  onUpdate,
  id,
  settings
}) {
  const {
    keys
  } = settings;
  return React.createElement(SelectContainer, null, React.createElement(NativeSelect, {
    id: id,
    value: displayValue,
    onChange: e => onUpdate(e.currentTarget.value)
  }, keys.map(key => React.createElement("option", {
    key: key,
    value: key
  }, key))), React.createElement(PresentationalSelect, null, displayValue), React.createElement(Chevron, {
    toggled: true
  }));
}

function SelectComponent() {
  const {
    label,
    displayValue,
    onUpdate,
    id,
    settings
  } = useInputContext();
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(Select, {
    id: id,
    displayValue: displayValue,
    onUpdate: onUpdate,
    settings: settings
  }));
}

var select = createInternalPlugin(_objectSpread2({
  component: SelectComponent
}, props$5));

const convertMap = {
  rgb: 'toRgb',
  hsl: 'toHsl',
  hsv: 'toHsv',
  hex: 'toHexString',
  hex8: 'toHex8String'
};
v8n.extend({
  color: () => value => tc(value).isValid()
});
const schema$4 = o => v8n().color().test(o);

function convert(color, {
  format,
  hasAlpha,
  isString
}) {
  const _format = format === 'hex' && hasAlpha ? 'hex8' : format;

  if (isString) return color.toString(_format);

  const colorObj = color[convertMap[_format]]();

  return hasAlpha ? colorObj : omit(colorObj, ['a']);
}

const sanitize$4 = (v, settings) => {
  const color = tc(v);
  if (!color.isValid()) throw Error('Invalid color');
  return convert(color, settings);
};
const format$1 = (v, settings) => {
  return convert(tc(v), _objectSpread2(_objectSpread2({}, settings), {}, {
    isString: true,
    format: 'hex'
  }));
};
const normalize$3 = ({
  value
}) => {
  const color = tc(value);

  const _f = color.getFormat();

  const format = _f === 'name' || _f === 'hex8' ? 'hex' : _f;
  const hasAlpha = typeof value === 'object' ? 'a' in value : _f === 'hex8' || /^(rgba)|(hsla)|(hsva)/.test(value);
  const settings = {
    format,
    hasAlpha,
    isString: typeof value === 'string'
  };
  return {
    value: sanitize$4(value, settings),
    settings
  };
};

var props$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  schema: schema$4,
  sanitize: sanitize$4,
  format: format$1,
  normalize: normalize$3
});

const ColorPreview = styled('div', {
  position: 'relative',
  boxSizing: 'border-box',
  borderRadius: '$leva__sm',
  overflow: 'hidden',
  cursor: 'pointer',
  height: '$leva__rowHeight',
  width: '$leva__rowHeight',
  backgroundColor: '#fff',
  backgroundImage: `url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`,
  $leva__inputStyle: '',
  $leva__hover: '',
  zIndex: 1,
  variants: {
    active: {
      true: {
        $leva__inputStyle: '$leva__accent1'
      }
    }
  },
  '&::before': {
    content: '""',
    position: 'absolute',
    top: 0,
    bottom: 0,
    right: 0,
    left: 0,
    backgroundColor: 'currentColor',
    zIndex: 1
  }
});
const PickerContainer = styled('div', {
  position: 'relative',
  display: 'grid',
  gridTemplateColumns: '$sizes$leva__rowHeight auto',
  columnGap: '$leva__colGap',
  alignItems: 'center'
});
const PickerWrapper = styled('div', {
  width: '$leva__colorPickerWidth',
  height: '$leva__colorPickerHeight',
  '.react-colorful': {
    width: '100%',
    height: '100%',
    boxShadow: '$leva__level2',
    cursor: 'crosshair'
  },
  '.react-colorful__saturation': {
    borderRadius: '$leva__sm $leva__sm 0 0'
  },
  '.react-colorful__alpha, .react-colorful__hue': {
    height: 10
  },
  '.react-colorful__last-control': {
    borderRadius: '0 0 $leva__sm $leva__sm'
  },
  '.react-colorful__pointer': {
    height: 12,
    width: 12
  }
});

function convertToRgb(value, format) {
  return format !== 'rgb' ? tc(value).toRgb() : value;
}

function Color({
  value,
  displayValue,
  settings,
  onUpdate
}) {
  const {
    format,
    hasAlpha
  } = settings;
  const {
    popinRef,
    wrapperRef,
    shown,
    show,
    hide
  } = usePopin();
  const timer = useRef(0);
  const [initialRgb, setInitialRgb] = useState(() => convertToRgb(value, format));
  const ColorPicker = hasAlpha ? RgbaColorPicker : RgbColorPicker;

  const showPicker = () => {
    setInitialRgb(convertToRgb(value, format));
    show();
  };

  const hideAfterDelay = () => {
    timer.current = window.setTimeout(hide, 500);
  };

  return React.createElement(React.Fragment, null, React.createElement(ColorPreview, {
    ref: popinRef,
    active: shown,
    onClick: () => showPicker(),
    style: {
      color: displayValue
    }
  }), shown && React.createElement(Portal, null, React.createElement(Overlay, {
    onPointerUp: hide
  }), React.createElement(PickerWrapper, {
    ref: wrapperRef,
    onMouseEnter: () => window.clearTimeout(timer.current),
    onMouseLeave: e => e.buttons === 0 && hideAfterDelay()
  }, React.createElement(ColorPicker, {
    color: initialRgb,
    onChange: onUpdate
  }))));
}
function ColorComponent() {
  const {
    value,
    displayValue,
    label,
    onChange,
    onUpdate,
    settings
  } = useInputContext();
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(PickerContainer, null, React.createElement(Color, {
    value: value,
    displayValue: displayValue,
    onChange: onChange,
    onUpdate: onUpdate,
    settings: settings
  }), React.createElement(ValueInput, {
    value: displayValue,
    onChange: onChange,
    onUpdate: onUpdate
  })));
}

var color = createInternalPlugin(_objectSpread2({
  component: ColorComponent
}, props$4));

const schema$3 = o => v8n().string().test(o);
const sanitize$3 = v => {
  if (typeof v !== 'string') throw Error(`Invalid string`);
  return v;
};

var props$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  schema: schema$3,
  sanitize: sanitize$3
});

function String$1({
  displayValue,
  onUpdate,
  onChange
}) {
  return React.createElement(ValueInput, {
    value: displayValue,
    onUpdate: onUpdate,
    onChange: onChange
  });
}
function StringComponent() {
  const {
    label,
    displayValue,
    onUpdate,
    onChange
  } = useInputContext();
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(String$1, {
    displayValue: displayValue,
    onUpdate: onUpdate,
    onChange: onChange
  }));
}

var string = createInternalPlugin(_objectSpread2({
  component: StringComponent
}, props$3));

const schema$2 = o => v8n().boolean().test(o);
const sanitize$2 = v => {
  if (typeof v !== 'boolean') throw Error('Invalid boolean');
  return v;
};

var props$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  schema: schema$2,
  sanitize: sanitize$2
});

const StyledInputWrapper = styled('div', {
  position: 'relative',
  $leva__flex: '',
  height: '$leva__rowHeight',
  input: {
    $leva__reset: '',
    height: 0,
    width: 0,
    opacity: 0,
    margin: 0
  },
  label: {
    position: 'relative',
    $leva__flexCenter: '',
    WebkitUserSelect: 'none',
    userSelect: 'none',
    cursor: 'pointer',
    height: '$leva__checkboxSize',
    width: '$leva__checkboxSize',
    backgroundColor: '$leva__elevation3',
    borderRadius: '$leva__sm',
    $leva__hover: ''
  },
  'input:focus + label': {
    $leva__focusStyle: ''
  },
  'input:focus:checked + label, input:checked + label:hover': {
    $leva__hoverStyle: '$leva__accent3'
  },
  'input + label:active': {
    backgroundColor: '$leva__accent1'
  },
  'input:checked + label:active': {
    backgroundColor: '$leva__accent1'
  },
  'label > svg': {
    display: 'none',
    width: '90%',
    height: '90%',
    stroke: '$leva__highlight3'
  },
  'input:checked + label': {
    backgroundColor: '$leva__accent2'
  },
  'input:checked + label > svg': {
    display: 'block'
  }
});

function Boolean$1({
  value,
  onUpdate,
  id
}) {
  return React.createElement(StyledInputWrapper, null, React.createElement("input", {
    id: id,
    type: "checkbox",
    checked: value,
    onChange: e => onUpdate(e.currentTarget.checked)
  }), React.createElement("label", {
    htmlFor: id
  }, React.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24"
  }, React.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    d: "M5 13l4 4L19 7"
  }))));
}
function BooleanComponent() {
  const {
    label,
    value,
    onUpdate,
    id
  } = useInputContext();
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(Boolean$1, {
    value: value,
    onUpdate: onUpdate,
    id: id
  }));
}

var boolean = createInternalPlugin(_objectSpread2({
  component: BooleanComponent
}, props$2));

function Vector3dComponent() {
  const {
    label,
    displayValue,
    onUpdate,
    settings
  } = useInputContext();
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(Vector, {
    value: displayValue,
    settings: settings,
    onUpdate: onUpdate
  }));
}

var vector3d = createInternalPlugin(_objectSpread2({
  component: Vector3dComponent
}, getVectorPlugin(['x', 'y', 'z'])));

const JoystickTrigger = styled('div', {
  $leva__flexCenter: '',
  position: 'relative',
  backgroundColor: '$leva__elevation3',
  borderRadius: '$leva__sm',
  cursor: 'pointer',
  height: '$leva__rowHeight',
  width: '$leva__rowHeight',
  $leva__draggable: '',
  $leva__hover: '',
  '&:active': {
    cursor: 'none'
  },
  '&::after': {
    content: '""',
    backgroundColor: '$leva__accent2',
    height: 4,
    width: 4,
    borderRadius: 2
  }
});
const JoystickPlayground = styled('div', {
  $leva__flexCenter: '',
  width: '$leva__joystickWidth',
  height: '$leva__joystickHeight',
  borderRadius: '$leva__sm',
  boxShadow: '$leva__level2',
  position: 'fixed',
  zIndex: 10000,
  overflow: 'hidden',
  $leva__draggable: '',
  transform: 'translate(-50%, -50%)',
  variants: {
    isOutOfBounds: {
      true: {
        backgroundColor: '$leva__elevation1'
      },
      false: {
        backgroundColor: '$leva__elevation3'
      }
    }
  },
  '> div': {
    position: 'absolute',
    $leva__flexCenter: '',
    borderStyle: 'solid',
    borderWidth: 1,
    borderColor: '$leva__highlight1',
    backgroundColor: '$leva__elevation3',
    width: '80%',
    height: '80%',
    '&::after,&::before': {
      content: '""',
      position: 'absolute',
      zindex: 10,
      backgroundColor: '$leva__highlight1'
    },
    '&::before': {
      width: '100%',
      height: 1
    },
    '&::after': {
      height: '100%',
      width: 1
    }
  },
  '> span': {
    position: 'relative',
    zindex: 100,
    width: 10,
    height: 10,
    backgroundColor: '$leva__accent2',
    borderRadius: '50%'
  }
});

function Joystick({
  value,
  settings,
  onUpdate
}) {
  const timeout = useRef();
  const outOfBoundsX = useRef(0);
  const outOfBoundsY = useRef(0);
  const stepMultiplier = useRef(1);
  const [joystickShown, setShowJoystick] = useState(false);
  const [isOutOfBounds, setIsOutOfBounds] = useState(false);
  const [spanRef, set] = useTransform();
  const joystickeRef = useRef(null);
  const playgroundRef = useRef(null);
  useLayoutEffect(() => {
    if (joystickShown) {
      const {
        top,
        left,
        width,
        height
      } = joystickeRef.current.getBoundingClientRect();
      playgroundRef.current.style.left = left + width / 2 + 'px';
      playgroundRef.current.style.top = top + height / 2 + 'px';
    }
  }, [joystickShown]);
  const {
    keys: [v1, v2]
  } = settings;
  const {
    [v1]: {
      step: stepV1
    },
    [v2]: {
      step: stepV2
    }
  } = settings;
  const wpx = useTh('sizes', 'leva__joystickWidth');
  const hpx = useTh('sizes', 'leva__joystickHeight');
  const w = parseFloat(wpx) * 0.8 / 2;
  const h = parseFloat(hpx) * 0.8 / 2;
  const startOutOfBounds = useCallback(() => {
    if (timeout.current) return;
    setIsOutOfBounds(true);
    if (outOfBoundsX.current) set({
      x: outOfBoundsX.current * w
    });
    if (outOfBoundsY.current) set({
      y: outOfBoundsY.current * -h
    });
    timeout.current = window.setInterval(() => {
      onUpdate(v => {
        const incX = stepV1 * outOfBoundsX.current * stepMultiplier.current;
        const incY = stepV2 * outOfBoundsY.current * stepMultiplier.current;
        return Array.isArray(v) ? {
          [v1]: v[0] + incX,
          [v2]: v[1] + incY
        } : {
          [v1]: v[v1] + incX,
          [v2]: v[v2] + incY
        };
      });
    }, 16);
  }, [w, h, onUpdate, set, stepV1, stepV2, v1, v2]);
  const endOutOfBounds = useCallback(() => {
    window.clearTimeout(timeout.current);
    timeout.current = undefined;
    setIsOutOfBounds(false);
  }, []);
  useEffect(() => {
    function setStepMultiplier(event) {
      stepMultiplier.current = multiplyStep(event);
    }

    window.addEventListener('keydown', setStepMultiplier);
    window.addEventListener('keyup', setStepMultiplier);
    return () => {
      window.clearTimeout(timeout.current);
      window.removeEventListener('keydown', setStepMultiplier);
      window.removeEventListener('keyup', setStepMultiplier);
    };
  }, []);
  const bind = useDrag(({
    first,
    active,
    delta: [dx, dy],
    movement: [mx, my]
  }) => {
    if (first) setShowJoystick(true);

    const _x = clamp(mx, -w, w);

    const _y = clamp(my, -h, h);

    outOfBoundsX.current = Math.abs(mx) > Math.abs(_x) ? Math.sign(mx - _x) : 0;
    outOfBoundsY.current = Math.abs(my) > Math.abs(_y) ? Math.sign(_y - my) : 0;
    let newX = value[v1];
    let newY = value[v2];

    if (active) {
      if (!outOfBoundsX.current) {
        newX += dx * stepV1 * stepMultiplier.current;
        set({
          x: _x
        });
      }

      if (!outOfBoundsY.current) {
        newY -= dy * stepV2 * stepMultiplier.current;
        set({
          y: _y
        });
      }

      if (outOfBoundsX.current || outOfBoundsY.current) startOutOfBounds();else endOutOfBounds();
      onUpdate({
        [v1]: newX,
        [v2]: newY
      });
    } else {
      setShowJoystick(false);
      outOfBoundsX.current = 0;
      outOfBoundsY.current = 0;
      set({
        x: 0,
        y: 0
      });
      endOutOfBounds();
    }
  });
  return React.createElement(JoystickTrigger, _extends({
    ref: joystickeRef
  }, bind()), joystickShown && React.createElement(Portal, null, React.createElement(JoystickPlayground, {
    ref: playgroundRef,
    isOutOfBounds: isOutOfBounds
  }, React.createElement("div", null), React.createElement("span", {
    ref: spanRef
  }))));
}

const Container$1 = styled('div', {
  display: 'grid',
  columnGap: '$leva__colGap',
  variants: {
    withJoystick: {
      true: {
        gridTemplateColumns: '$sizes$leva__rowHeight auto'
      },
      false: {
        gridTemplateColumns: 'auto'
      }
    }
  }
});
function Vector2dComponent() {
  const {
    label,
    displayValue,
    onUpdate,
    settings
  } = useInputContext();
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(Container$1, {
    withJoystick: settings.joystick
  }, settings.joystick && React.createElement(Joystick, {
    value: displayValue,
    settings: settings,
    onUpdate: onUpdate
  }), React.createElement(Vector, {
    value: displayValue,
    settings: settings,
    onUpdate: onUpdate
  })));
}

const plugin = getVectorPlugin(['x', 'y']);

const normalize$2 = (_ref) => {
  let {
    joystick = true
  } = _ref,
      input = _objectWithoutProperties(_ref, ["joystick"]);

  const {
    value,
    settings
  } = plugin.normalize(input);
  return {
    value,
    settings: _objectSpread2(_objectSpread2({}, settings), {}, {
      joystick
    })
  };
};

var vector2d = createInternalPlugin(_objectSpread2(_objectSpread2({
  component: Vector2dComponent
}, plugin), {}, {
  normalize: normalize$2
}));

const sanitize$1 = v => {
  if (v === undefined) return undefined;

  if (v instanceof File) {
    try {
      return URL.createObjectURL(v);
    } catch (e) {
      return undefined;
    }
  }

  if (typeof v === 'string' && v.indexOf('blob:') === 0) return v;
  throw Error(`Invalid image format [undefined | blob | File].`);
};
const schema$1 = (_o, s) => typeof s === 'object' && 'image' in s;
const normalize$1 = ({
  image
}) => {
  return {
    value: image
  };
};

var props$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sanitize: sanitize$1,
  schema: schema$1,
  normalize: normalize$1
});

const ImageContainer = styled('div', {
  position: 'relative',
  display: 'grid',
  gridTemplateColumns: '$sizes$leva__rowHeight auto 20px',
  columnGap: '$leva__colGap',
  alignItems: 'center'
});
const DropZone = styled('div', {
  $leva__flexCenter: '',
  overflow: 'hidden',
  height: '$leva__rowHeight',
  background: '$leva__elevation3',
  textAlign: 'center',
  color: 'inherit',
  borderRadius: '$leva__sm',
  outline: 'none',
  WebkitUserSelect: 'none',
  userSelect: 'none',
  cursor: 'pointer',
  $leva__inputStyle: '',
  $leva__hover: '',
  $leva__focusWithin: '',
  $leva__active: '$leva__accent1 $leva__elevation1',
  variants: {
    isDragAccept: {
      true: {
        $leva__inputStyle: '$leva__accent1',
        backgroundColor: '$leva__elevation1'
      }
    }
  }
});
const ImagePreview = styled('div', {
  boxSizing: 'border-box',
  borderRadius: '$leva__sm',
  height: '$leva__rowHeight',
  width: '$leva__rowHeight',
  $leva__inputStyle: '',
  backgroundSize: 'cover',
  backgroundPosition: 'center',
  variants: {
    hasImage: {
      true: {
        cursor: 'pointer',
        $leva__hover: '',
        $leva__active: ''
      }
    }
  }
});
const ImageLargePreview = styled('div', {
  $leva__flexCenter: '',
  width: '$leva__imagePreviewWidth',
  height: '$leva__imagePreviewHeight',
  borderRadius: '$leva__sm',
  boxShadow: '$leva__level2',
  pointerEvents: 'none',
  $leva__inputStyle: '',
  backgroundSize: 'cover',
  backgroundPosition: 'center'
});
const Instructions = styled('div', {
  fontSize: '0.8em',
  height: '100%',
  padding: '$leva__rowGap $leva__md'
});
const Remove = styled('div', {
  $leva__flexCenter: '',
  top: '0',
  right: '0',
  marginRight: '$leva__sm',
  height: '100%',
  cursor: 'pointer',
  variants: {
    disabled: {
      true: {
        color: '$leva__elevation3',
        cursor: 'default'
      }
    }
  },
  '&::after,&::before': {
    content: '""',
    position: 'absolute',
    height: 2,
    width: 10,
    borderRadius: 1,
    backgroundColor: 'currentColor'
  },
  '&::after': {
    transform: 'rotate(45deg)'
  },
  '&::before': {
    transform: 'rotate(-45deg)'
  }
});

function ImageComponent() {
  const {
    label,
    value,
    onUpdate
  } = useInputContext();
  const {
    popinRef,
    wrapperRef,
    shown,
    show,
    hide
  } = usePopin();
  const onDrop = useCallback(acceptedFiles => {
    if (acceptedFiles.length) onUpdate(acceptedFiles[0]);
  }, [onUpdate]);
  const clear = useCallback(e => {
    e.stopPropagation();
    onUpdate(undefined);
  }, [onUpdate]);
  const {
    getRootProps,
    getInputProps,
    isDragAccept
  } = useDropzone({
    maxFiles: 1,
    accept: 'image/*',
    onDrop
  });
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(ImageContainer, null, React.createElement(ImagePreview, {
    ref: popinRef,
    hasImage: !!value,
    onPointerDown: () => !!value && show(),
    onPointerUp: hide,
    style: {
      backgroundImage: value ? `url(${value})` : 'none'
    }
  }), shown && !!value && React.createElement(Portal, null, React.createElement(Overlay, {
    onPointerUp: hide,
    style: {
      cursor: 'pointer'
    }
  }), React.createElement(ImageLargePreview, {
    ref: wrapperRef,
    style: {
      backgroundImage: `url(${value})`
    }
  })), React.createElement(DropZone, getRootProps({
    isDragAccept
  }), React.createElement("input", getInputProps()), React.createElement(Instructions, null, isDragAccept ? 'drop image' : 'click or drop')), React.createElement(Remove, {
    onClick: clear,
    disabled: !value
  })));
}

var image = createInternalPlugin(_objectSpread2({
  component: ImageComponent
}, props$1));

const number = v8n().number();
const schema = (o, s) => v8n().array().length(2).every.number().test(o) && v8n().schema({
  min: number,
  max: number
}).test(s);
const format = v => ({
  min: v[0],
  max: v[1]
});
const sanitize = (value, {
  bounds: [MIN, MAX]
}, prevValue) => {
  const _newValue = {
    min: prevValue[0],
    max: prevValue[1]
  };

  const {
    min,
    max
  } = _objectSpread2(_objectSpread2({}, _newValue), value);

  return [clamp(Number(min), MIN, Math.max(MIN, max)), clamp(Number(max), Math.min(MAX, min), MAX)];
};
const normalize = ({
  value,
  min,
  max
}) => {
  const boundsSettings = {
    min,
    max
  };
  const settings = normalizeKeyedNumberSettings(format(value), {
    min: boundsSettings,
    max: boundsSettings
  });
  const bounds = [min, max];
  return {
    value,
    settings: _objectSpread2(_objectSpread2({}, settings), {}, {
      bounds
    })
  };
};

var props = /*#__PURE__*/Object.freeze({
  __proto__: null,
  schema: schema,
  format: format,
  sanitize: sanitize,
  normalize: normalize
});

const Container = styled('div', {
  display: 'grid',
  columnGap: '$leva__colGap',
  gridTemplateColumns: 'auto calc($sizes$leva__numberInputMinWidth * 2 + $space$leva__rowGap)'
});

function IntervalSlider(_ref) {
  let {
    value,
    bounds: [min, max],
    onDrag
  } = _ref,
      settings = _objectWithoutProperties(_ref, ["value", "bounds", "onDrag"]);

  const ref = useRef(null);
  const minScrubberRef = useRef(null);
  const maxScrubberRef = useRef(null);
  const rangeWidth = useRef(0);
  const scrubberWidth = useTh('sizes', 'leva__scrubberWidth');
  const bind = useDrag$1(({
    event,
    first,
    xy: [x],
    movement: [mx],
    memo: _memo = {}
  }) => {
    if (first) {
      const {
        width,
        left
      } = ref.current.getBoundingClientRect();
      rangeWidth.current = width - parseFloat(scrubberWidth);
      const targetIsScrub = (event === null || event === void 0 ? void 0 : event.target) === minScrubberRef.current || (event === null || event === void 0 ? void 0 : event.target) === maxScrubberRef.current;
      _memo.pos = invertedRange((x - left) / width, min, max);
      const delta = Math.abs(_memo.pos - value.min) - Math.abs(_memo.pos - value.max);
      _memo.key = delta < 0 || delta === 0 && _memo.pos <= value.min ? 'min' : 'max';
      if (targetIsScrub) _memo.pos = value[_memo.key];
    }

    const newValue = _memo.pos + invertedRange(mx / rangeWidth.current, 0, max - min);
    onDrag({
      [_memo.key]: sanitizeStep(newValue, settings[_memo.key])
    });
    return _memo;
  });
  const minStyle = `calc(${range(value.min, min, max)} * (100% - ${scrubberWidth}))`;
  const maxStyle = `calc(${1 - range(value.max, min, max)} * (100% - ${scrubberWidth}))`;
  return React.createElement(RangeWrapper, _extends({
    ref: ref
  }, bind()), React.createElement(Range, null, React.createElement(Indicator, {
    style: {
      left: minStyle,
      right: maxStyle
    }
  })), React.createElement(Scrubber, {
    position: "left",
    ref: minScrubberRef,
    style: {
      left: minStyle
    }
  }), React.createElement(Scrubber, {
    position: "right",
    ref: maxScrubberRef,
    style: {
      right: maxStyle
    }
  }));
}

function IntervalComponent() {
  const {
    label,
    displayValue,
    onUpdate,
    settings
  } = useInputContext();

  const _settings = _objectWithoutProperties(settings, ["bounds"]);

  return React.createElement(React.Fragment, null, React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(Container, null, React.createElement(IntervalSlider, _extends({
    value: displayValue
  }, settings, {
    onDrag: onUpdate
  })), React.createElement(Vector, {
    value: displayValue,
    settings: _settings,
    onUpdate: onUpdate,
    hideNumberLabels: true
  }))));
}

var interval = createInternalPlugin(_objectSpread2({
  component: IntervalComponent
}, props));

const Store = function Store() {
  const store = create(() => ({
    data: {}
  }));
  this.useStore = store;
  const folders = {};
  const orderedPaths = new Set();

  this.getVisiblePaths = () => {
    const data = this.getData();
    const paths = Object.keys(data);
    const hiddenFolders = [];
    Object.entries(folders).forEach(([path, settings]) => {
      if (settings.render && paths.some(p => p.indexOf(path) === 0) && !settings.render(this.get)) hiddenFolders.push(path + '.');
    });
    const visiblePaths = [];
    orderedPaths.forEach(path => {
      if (path in data && data[path].__refCount > 0 && hiddenFolders.every(p => path.indexOf(p) === -1) && (!data[path].render || data[path].render(this.get))) visiblePaths.push(path);
    });
    return visiblePaths;
  };

  this.setOrderedPaths = newPaths => {
    newPaths.forEach(p => orderedPaths.add(p));
  };

  this.orderPaths = paths => {
    this.setOrderedPaths(paths);
    return paths;
  };

  this.disposePaths = paths => {
    store.setState(s => {
      const data = s.data;
      paths.forEach(path => {
        if (path in data) {
          const input = data[path];
          input.__refCount--;

          if (input.__refCount === 0 && input.type in SpecialInputTypes) {
            delete data[path];
          }
        }
      });
      return {
        data
      };
    });
  };

  this.dispose = () => {
    store.setState(() => {
      return {
        data: {}
      };
    });
  };

  this.getFolderSettings = path => {
    return folders[path] || {};
  };

  this.getData = () => {
    return store.getState().data;
  };

  this.addData = (newData, override) => {
    store.setState(s => {
      const data = s.data;
      Object.entries(newData).forEach(([path, newInputData]) => {
        let input = data[path];

        if (!!input) {
          const _ref = newInputData,
                {
            type,
            value
          } = _ref,
                rest = _objectWithoutProperties(_ref, ["type", "value"]);

          if (type !== input.type) {
            warn(LevaErrors.INPUT_TYPE_OVERRIDE, type);
          } else {
            if (input.__refCount === 0 || override) {
              Object.assign(input, rest);
            }

            input.__refCount++;
          }
        } else {
          data[path] = _objectSpread2(_objectSpread2({}, newInputData), {}, {
            __refCount: 1
          });
        }
      });
      return {
        data
      };
    });
  };

  this.setValueAtPath = (path, value) => {
    store.setState(s => {
      const data = s.data;
      updateInput(data[path], value);
      return {
        data
      };
    });
  };

  this.setSettingsAtPath = (path, settings) => {
    store.setState(s => {
      const data = s.data;
      data[path].settings = _objectSpread2(_objectSpread2({}, data[path].settings), settings);
      return {
        data
      };
    });
  };

  this.disableInputAtPath = (path, flag) => {
    store.setState(s => {
      const data = s.data;
      data[path].disabled = flag;
      return {
        data
      };
    });
  };

  this.set = values => {
    store.setState(s => {
      const data = s.data;
      Object.entries(values).forEach(([path, value]) => {
        try {
          updateInput(data[path], value);
        } catch (_unused) {}
      });
      return {
        data
      };
    });
  };

  this.get = path => {
    try {
      return this.getData()[path].value;
    } catch (e) {
      warn(LevaErrors.PATH_DOESNT_EXIST, path);
    }
  };

  const _getDataFromSchema = (schema, rootPath, mappedPaths) => {
    const data = {};
    Object.entries(schema).forEach(([key, input]) => {
      let newPath = join(rootPath, key);

      if (input.type === SpecialInputTypes.FOLDER) {
        const newData = _getDataFromSchema(input.schema, newPath, mappedPaths);

        Object.assign(data, newData);
        if (!(newPath in folders)) folders[newPath] = input.settings;
      } else if (key in mappedPaths) {
        warn(LevaErrors.DUPLICATE_KEYS, key, newPath, mappedPaths[key]);
      } else {
        mappedPaths[key] = newPath;
        let _render = undefined;
        let _label = undefined;
        let _hint = undefined;

        let _optional;

        let _disabled;

        let _input = input;

        if (typeof input === 'object' && !Array.isArray(input)) {
          const {
            render,
            label,
            optional,
            disabled,
            hint
          } = input,
                rest = _objectWithoutProperties(input, ["render", "label", "optional", "disabled", "hint"]);

          _label = label;
          _render = render;
          _input = rest;
          _optional = optional;
          _disabled = disabled;
          _hint = hint;
        }

        const normalizedInput = normalizeInput(_input, newPath);

        if (normalizedInput) {
          var _label2;

          data[newPath] = normalizedInput;
          data[newPath].key = key;
          data[newPath].label = (_label2 = _label) !== null && _label2 !== void 0 ? _label2 : key;
          data[newPath].hint = _hint;

          if (!(input.type in SpecialInputTypes)) {
            var _optional2, _disabled2;

            data[newPath].optional = (_optional2 = _optional) !== null && _optional2 !== void 0 ? _optional2 : false;
            data[newPath].disabled = (_disabled2 = _disabled) !== null && _disabled2 !== void 0 ? _disabled2 : false;
          }

          if (typeof _render === 'function') data[newPath].render = _render;
        }
      }
    });
    return data;
  };

  this.getDataFromSchema = schema => {
    const mappedPaths = {};

    const data = _getDataFromSchema(schema, '', mappedPaths);

    return [data, mappedPaths];
  };
};
const levaStore = new Store();
function useCreateStore() {
  return useMemo(() => new Store(), []);
}

if (process.env.NODE_ENV === 'development' && typeof window !== 'undefined') {
  window.__LEVA__STORE = levaStore;
}

const defaultSettings$1 = {
  collapsed: false
};
function folder(schema, settings) {
  return {
    type: SpecialInputTypes.FOLDER,
    schema,
    settings: _objectSpread2(_objectSpread2({}, defaultSettings$1), settings)
  };
}

function button(onClick) {
  return {
    type: SpecialInputTypes.BUTTON,
    onClick
  };
}

function buttonGroup(opts) {
  return {
    type: SpecialInputTypes.BUTTON_GROUP,
    opts
  };
}

const defaultSettings = {
  graph: false,
  interval: 100
};
function monitor(objectOrFn, settings) {
  return {
    type: SpecialInputTypes.MONITOR,
    objectOrFn,
    settings: _objectSpread2(_objectSpread2({}, defaultSettings), settings)
  };
}

const isInput = v => '__levaInput' in v;
const buildTree = (paths, filter) => {
  const tree = {};

  const _filter = filter ? filter.toLowerCase() : null;

  paths.forEach(path => {
    const [valueKey, folderPath] = getKeyPath(path);

    if (!_filter || valueKey.toLowerCase().indexOf(_filter) > -1) {
      merge(tree, folderPath, {
        [valueKey]: {
          __levaInput: true,
          path
        }
      });
    }
  });
  return tree;
};

function FolderTitle({
  toggle,
  toggled,
  name
}) {
  return React.createElement(StyledTitle, {
    onClick: () => toggle()
  }, React.createElement(Chevron, {
    toggled: toggled
  }), React.createElement("div", null, name));
}

function ControlInput(_ref) {
  let {
    type,
    label,
    path,
    valueKey,
    value,
    settings,
    setValue,
    disabled
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["type", "label", "path", "valueKey", "value", "settings", "setValue", "disabled"]);

  const {
    displayValue,
    onChange,
    onUpdate
  } = useValue({
    type,
    value,
    settings,
    setValue
  });
  const Input = Plugins[type].component;

  if (!Input) {
    log(LevaErrors.NO_COMPONENT_FOR_TYPE, type, path);
    return null;
  }

  return React.createElement(InputContext.Provider, {
    value: _objectSpread2({
      key: valueKey,
      path,
      id: 'leva__' + path,
      label,
      displayValue,
      value,
      onChange,
      onUpdate,
      settings,
      setValue,
      disabled
    }, rest)
  }, React.createElement(StyledInputWrapper$1, {
    disabled: disabled
  }, React.createElement(Input, null)));
}

const StyledButton = styled('button', {
  display: 'block',
  $leva__reset: '',
  fontWeight: '$leva__button',
  color: '$leva__highlight3',
  height: '$leva__rowHeight',
  borderStyle: 'none',
  borderRadius: '$leva__sm',
  backgroundColor: '$leva__accent2',
  cursor: 'pointer',
  $leva__hover: '$leva__accent3',
  $leva__active: '$leva__accent3 $leva__accent1',
  $leva__focus: ''
});

function Button({
  onClick,
  label
}) {
  return React.createElement(Row, null, React.createElement(StyledButton, {
    onClick: () => onClick()
  }, label));
}

const StyledButtonGroup = styled('div', {
  $leva__flex: '',
  justifyContent: 'flex-end',
  gap: '$leva__colGap'
});

const StyledButtonGroupButton = styled('button', {
  $leva__reset: '',
  cursor: 'pointer',
  borderRadius: '$leva__xs',
  '&:hover': {
    backgroundColor: '$leva__elevation3'
  }
});

function ButtonGroup({
  label,
  opts
}) {
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(StyledButtonGroup, null, Object.entries(opts).map(([label, onClick]) => React.createElement(StyledButtonGroupButton, {
    key: label,
    onClick: () => onClick()
  }, label))));
}

const Canvas = styled('canvas', {
  height: '$leva__monitorHeight',
  width: '100%',
  display: 'block',
  borderRadius: '$leva__sm'
});

const POINTS = 100;

function push(arr, val) {
  arr.push(val);
  if (arr.length > POINTS) arr.shift();
}

const MonitorCanvas = forwardRef(function ({
  initialValue
}, ref) {
  const accentColor = useTh('colors', 'leva__highlight3');
  const backgroundColor = useTh('colors', 'leva__elevation2');
  const fillColor = useTh('colors', 'leva__highlight1');
  const [gradientTop, gradientBottom] = useMemo(() => {
    return [tc(fillColor).setAlpha(0.4).toRgbString(), tc(fillColor).setAlpha(0.1).toRgbString()];
  }, [fillColor]);
  const points = useRef([initialValue]);
  const min = useRef(initialValue);
  const max = useRef(initialValue);
  const raf = useRef();
  const drawPlot = useCallback((_canvas, _ctx) => {
    if (!_canvas) return;
    const {
      width,
      height
    } = _canvas;
    const path = new Path2D();
    const interval = width / POINTS;
    const verticalPadding = height * 0.05;

    for (let i = 0; i < points.current.length; i++) {
      const p = range(points.current[i], min.current, max.current);
      const x = interval * i;
      const y = height - p * (height - verticalPadding * 2) - verticalPadding;
      path.lineTo(x, y);
    }

    _ctx.clearRect(0, 0, width, height);

    const gradientPath = new Path2D(path);
    gradientPath.lineTo(interval * (points.current.length + 1), height);
    gradientPath.lineTo(0, height);
    gradientPath.lineTo(0, 0);

    const gradient = _ctx.createLinearGradient(0, 0, 0, height);

    gradient.addColorStop(0.0, gradientTop);
    gradient.addColorStop(1.0, gradientBottom);
    _ctx.fillStyle = gradient;

    _ctx.fill(gradientPath);

    _ctx.strokeStyle = backgroundColor;
    _ctx.lineJoin = 'round';
    _ctx.lineWidth = 14;

    _ctx.stroke(path);

    _ctx.strokeStyle = accentColor;
    _ctx.lineWidth = 2;

    _ctx.stroke(path);
  }, [accentColor, backgroundColor, gradientTop, gradientBottom]);
  const [canvas, ctx] = useCanvas2d(drawPlot);
  useImperativeHandle(ref, () => ({
    frame: val => {
      if (min.current === undefined || val < min.current) min.current = val;
      if (max.current === undefined || val > max.current) max.current = val;
      push(points.current, val);
      raf.current = requestAnimationFrame(() => drawPlot(canvas.current, ctx.current));
    }
  }), [canvas, ctx, drawPlot]);
  useEffect(() => () => cancelAnimationFrame(raf.current), []);
  return React.createElement(Canvas, {
    ref: canvas
  });
});

const parse = val => Number.isFinite(val) ? val.toPrecision(2) : val.toString();

const MonitorLog = forwardRef(function ({
  initialValue
}, ref) {
  const [val, set] = useState(parse(initialValue));
  useImperativeHandle(ref, () => ({
    frame: v => set(parse(v))
  }), []);
  return React.createElement("div", null, val);
});

function getValue(o) {
  return typeof o === 'function' ? o() : o.current;
}

function Monitor({
  label,
  objectOrFn,
  settings
}) {
  const ref = useRef();
  const initialValue = useRef(getValue(objectOrFn));
  useEffect(() => {
    const timeout = window.setInterval(() => {
      var _ref$current;

      return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.frame(getValue(objectOrFn));
    }, settings.interval);
    return () => window.clearInterval(timeout);
  }, [objectOrFn, settings.interval]);
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, {
    align: "top"
  }, label), settings.graph ? React.createElement(MonitorCanvas, {
    ref: ref,
    initialValue: initialValue.current
  }) : React.createElement(MonitorLog, {
    ref: ref,
    initialValue: initialValue.current
  }));
}

const specialComponents = {
  [SpecialInputTypes.BUTTON]: Button,
  [SpecialInputTypes.BUTTON_GROUP]: ButtonGroup,
  [SpecialInputTypes.MONITOR]: Monitor
};
const Control = React.memo(({
  path
}) => {
  const [input, {
    set,
    setSettings,
    disable
  }] = useInput(path);
  if (!input) return null;

  const {
    type,
    label,
    key
  } = input,
        inputProps = _objectWithoutProperties(input, ["type", "label", "key"]);

  if (type in SpecialInputTypes) {
    const SpecialInputForType = specialComponents[type];
    return React.createElement(SpecialInputForType, _extends({
      label: label,
      path: path
    }, inputProps));
  }

  if (!(type in Plugins)) {
    log(LevaErrors.UNSUPPORTED_INPUT, type, path);
    return null;
  }

  return React.createElement(ControlInput, _extends({
    type: type,
    label: label,
    path: path,
    valueKey: key,
    setValue: set,
    setSettings: setSettings,
    disable: disable
  }, inputProps));
});

const Folder = ({
  name,
  path,
  tree
}) => {
  const store = useStoreContext();
  const newPath = join(path, name);
  const {
    collapsed
  } = store.getFolderSettings(newPath);
  const [toggled, setToggle] = useState(!collapsed);
  return React.createElement(StyledFolder, null, React.createElement(FolderTitle, {
    name: name,
    toggled: toggled,
    toggle: () => setToggle(t => !t)
  }), React.createElement(TreeWrapper, {
    parent: newPath,
    tree: tree,
    toggled: toggled
  }));
};

const TreeWrapper = React.memo(({
  isRoot: _isRoot = false,
  fill: _fill = false,
  flat: _flat = false,
  parent,
  tree,
  toggled
}) => {
  const {
    wrapperRef,
    contentRef
  } = useToggle(toggled);
  return React.createElement(StyledWrapper, {
    ref: wrapperRef,
    isRoot: _isRoot,
    fill: _fill,
    flat: _flat
  }, React.createElement(StyledContent, {
    ref: contentRef,
    isRoot: _isRoot,
    toggled: toggled
  }, Object.entries(tree).map(([key, value]) => isInput(value) ? React.createElement(Control, {
    key: value.path,
    valueKey: value.valueKey,
    path: value.path
  }) : React.createElement(Folder, {
    key: key,
    name: key,
    path: parent,
    tree: value
  }))));
});

const StyledRoot = styled('div', {
  position: 'relative',
  fontFamily: '$leva__mono',
  fontSize: '$leva__root',
  color: '$leva__rootText',
  backgroundColor: '$leva__elevation1',
  variants: {
    fill: {
      false: {
        position: 'fixed',
        top: '10px',
        right: '10px',
        zIndex: 1000,
        width: '$leva__rootWidth'
      },
      true: {
        position: 'relative',
        width: '100%'
      }
    },
    flat: {
      false: {
        borderRadius: '$leva__lg',
        boxShadow: '$leva__level1'
      }
    },
    oneLineLabels: {
      true: {
        [`${StyledInputRow}`]: {
          gridTemplateColumns: 'auto',
          gridAutoColumns: 'minmax(max-content, 1fr)',
          gridAutoRows: 'minmax($sizes$leva__rowHeight), auto)',
          rowGap: 0,
          columnGap: 0,
          marginTop: '$leva__rowGap'
        }
      }
    },
    hideTitleBar: {
      true: {
        $$titleBarHeight: '0px'
      },
      false: {
        $$titleBarHeight: '$sizes$leva__titleBarHeight'
      }
    }
  },
  '&,*,*:after,*:before': {
    boxSizing: 'border-box'
  },
  '*::selection': {
    backgroundColor: '$leva__accent2'
  }
});

const Icon = styled('i', {
  $leva__flexCenter: '',
  width: 40,
  WebkitUserSelect: 'none',
  userSelect: 'none',
  cursor: 'pointer',
  '> svg': {
    fill: '$leva__highlight1',
    transition: 'transform 350ms ease, fill 250ms ease'
  },
  '&:hover > svg': {
    fill: '$leva__highlight3'
  },
  variants: {
    active: {
      true: {
        '> svg': {
          fill: '$leva__highlight2'
        }
      }
    }
  }
});
const StyledTitleWithFilter = styled('div', {
  display: 'flex',
  alignItems: 'stretch',
  justifyContent: 'space-between',
  height: '$leva__titleBarHeight',
  cursor: 'grab'
});
const FilterWrapper = styled('div', {
  $leva__flex: '',
  position: 'relative',
  width: '100%',
  overflow: 'hidden',
  transition: 'height 250ms ease',
  color: '$leva__highlight3',
  paddingLeft: '$leva__md',
  [`> ${Icon}`]: {
    height: 30
  },
  variants: {
    toggled: {
      true: {
        height: 30
      },
      false: {
        height: 0
      }
    }
  }
});
const StyledFilterInput = styled('input', {
  $leva__reset: '',
  flex: 1,
  position: 'relative',
  height: 30,
  width: '100%',
  backgroundColor: 'transparent',
  fontSize: '10px',
  borderRadius: '$leva__root',
  '&:focus': {},
  '&::placeholder': {
    color: '$leva__highlight2'
  }
});
const Drag = styled('div', {
  $leva__flexCenter: '',
  $leva__draggable: '',
  flex: 1,
  '> svg': {
    fill: '$leva__highlight1',
    transition: 'fill 250ms ease'
  },
  '&:hover > svg': {
    fill: '$leva__highlight3'
  }
});

const FilterInput = React.forwardRef(({
  setFilter
}, ref) => {
  const [value, set] = useState('');
  const debouncedOnChange = useMemo(() => debounce(setFilter, 250), [setFilter]);

  const clear = () => {
    setFilter('');
    set('');
  };

  const _onChange = e => {
    const v = e.currentTarget.value;
    set(v);
  };

  useEffect(() => {
    debouncedOnChange(value);
  }, [value, debouncedOnChange]);
  return React.createElement(React.Fragment, null, React.createElement(StyledFilterInput, {
    ref: ref,
    value: value,
    placeholder: "[Open filter with CMD+SHIFT+L]",
    onPointerDown: e => e.stopPropagation(),
    onChange: _onChange
  }), React.createElement(Icon, {
    onClick: () => clear(),
    style: {
      visibility: value ? 'visible' : 'hidden'
    }
  }, React.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    height: "14",
    width: "14",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, React.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
    clipRule: "evenodd"
  }))));
});
function TitleWithFilter({
  setFilter,
  onDrag,
  toggle,
  toggled
}) {
  const [filterShown, setShowFilter] = useState(false);
  const inputRef = useRef(null);
  useEffect(() => {
    var _inputRef$current, _inputRef$current2;

    if (filterShown) (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();else (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.blur();
  }, [filterShown]);
  const bind = useDrag(({
    offset: [x, y]
  }) => onDrag({
    x,
    y
  }), {
    filterTaps: true
  });
  useEffect(() => {
    const handleShortcut = event => {
      if (event.key === 'L' && event.shiftKey && event.metaKey) {
        setShowFilter(f => !f);
      }
    };

    window.addEventListener('keydown', handleShortcut);
    return () => window.removeEventListener('keydown', handleShortcut);
  }, []);
  return React.createElement(React.Fragment, null, React.createElement(StyledTitleWithFilter, null, React.createElement(Icon, {
    active: !toggled,
    onClick: () => toggle()
  }, React.createElement(Chevron, {
    toggled: toggled,
    width: 12,
    height: 8
  })), React.createElement(Drag, bind(), React.createElement("svg", {
    width: "20",
    height: "10",
    viewBox: "0 0 28 14",
    xmlns: "http://www.w3.org/2000/svg"
  }, React.createElement("circle", {
    cx: "2",
    cy: "2",
    r: "2"
  }), React.createElement("circle", {
    cx: "14",
    cy: "2",
    r: "2"
  }), React.createElement("circle", {
    cx: "26",
    cy: "2",
    r: "2"
  }), React.createElement("circle", {
    cx: "2",
    cy: "12",
    r: "2"
  }), React.createElement("circle", {
    cx: "14",
    cy: "12",
    r: "2"
  }), React.createElement("circle", {
    cx: "26",
    cy: "12",
    r: "2"
  }))), React.createElement(Icon, {
    active: filterShown,
    onClick: () => setShowFilter(f => !f)
  }, React.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    height: "20",
    viewBox: "0 0 20 20"
  }, React.createElement("path", {
    d: "M9 9a2 2 0 114 0 2 2 0 01-4 0z"
  }), React.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.415l2.261-2.261A4 4 0 1011 5z",
    clipRule: "evenodd"
  })))), React.createElement(FilterWrapper, {
    toggled: filterShown
  }, React.createElement(FilterInput, {
    ref: inputRef,
    setFilter: setFilter
  })));
}

function LevaRoot(_ref) {
  let {
    store,
    hidden = false,
    theme,
    collapsed = false
  } = _ref,
      props = _objectWithoutProperties(_ref, ["store", "hidden", "theme", "collapsed"]);

  const themeContext = useDeepMemo(() => mergeTheme(theme), [theme]);
  const [toggled, setToggle] = useState(!collapsed);
  if (!store || hidden) return null;
  return React.createElement(ThemeContext.Provider, {
    value: themeContext
  }, React.createElement(LevaCore, _extends({
    store: store
  }, props, {
    toggled: toggled,
    setToggle: setToggle,
    rootClass: themeContext.className
  })));
}
const LevaCore = React.memo(({
  store,
  rootClass,
  fill: _fill = false,
  flat: _flat = false,
  oneLineLabels: _oneLineLabels = false,
  hideTitleBar: _hideTitleBar = false,
  hideCopyButton: _hideCopyButton = false,
  toggled,
  setToggle
}) => {
  const paths = useVisiblePaths(store);
  const [filter, setFilter] = useState('');
  const tree = useMemo(() => buildTree(paths, filter), [paths, filter]);
  const [rootRef, set] = useTransform();
  const shouldShow = paths.length > 0;
  return React.createElement(PanelSettingsContext.Provider, {
    value: {
      hideCopyButton: _hideCopyButton
    }
  }, React.createElement(StyledRoot, {
    ref: rootRef,
    className: rootClass,
    fill: _fill,
    flat: _flat,
    oneLineLabels: _oneLineLabels,
    hideTitleBar: _hideTitleBar,
    style: {
      display: shouldShow ? 'block' : 'none'
    }
  }, !_hideTitleBar && React.createElement(TitleWithFilter, {
    onDrag: set,
    setFilter: setFilter,
    toggle: () => setToggle(t => !t),
    toggled: toggled
  }), shouldShow && React.createElement(StoreContext.Provider, {
    value: store
  }, React.createElement(TreeWrapper, {
    isRoot: true,
    fill: _fill,
    flat: _flat,
    tree: tree,
    toggled: toggled
  }))));
});

let rootInitialized = false;
let rootEl = null;
function Leva(_ref) {
  let {
    isRoot = false
  } = _ref,
      props = _objectWithoutProperties(_ref, ["isRoot"]);

  useEffect(() => {
    rootInitialized = true;

    if (!isRoot && rootEl) {
      rootEl.remove();
      rootEl = null;
    }

    return () => {
      if (!isRoot) rootInitialized = false;
    };
  }, [isRoot]);
  return React.createElement(LevaRoot, _extends({
    store: levaStore
  }, props));
}
function useRenderRoot(isGlobalPanel) {
  useEffect(() => {
    if (isGlobalPanel && !rootInitialized) {
      if (!rootEl) {
        rootEl = document.getElementById('leva__root') || Object.assign(document.createElement('div'), {
          id: 'leva__root'
        });

        if (document.body) {
          document.body.appendChild(rootEl);
          ReactDOM.render(React.createElement(Leva, {
            isRoot: true
          }), rootEl);
        }
      }

      rootInitialized = true;
    }
  }, [isGlobalPanel]);
}

function LevaPanel(_ref) {
  let {
    store
  } = _ref,
      props = _objectWithoutProperties(_ref, ["store"]);

  const parentStore = useStoreContext();

  const _store = store === undefined ? parentStore : store;

  return React.createElement(LevaRoot, _extends({
    store: _store
  }, props));
}

function parseArgs(schemaOrFolderName, settingsOrDepsOrSchema, depsOrSettingsOrFolderSettings, depsOrSettings, depsOrUndefined) {
  let schema;
  let folderName = undefined;
  let folderSettings;
  let hookSettings;
  let deps;

  if (typeof schemaOrFolderName === 'string') {
    folderName = schemaOrFolderName;
    schema = settingsOrDepsOrSchema;

    if (Array.isArray(depsOrSettingsOrFolderSettings)) {
      deps = depsOrSettingsOrFolderSettings;
    } else {
      if (depsOrSettingsOrFolderSettings) {
        if ('store' in depsOrSettingsOrFolderSettings) {
          hookSettings = depsOrSettingsOrFolderSettings;
          deps = depsOrSettings;
        } else {
          folderSettings = depsOrSettingsOrFolderSettings;

          if (Array.isArray(depsOrSettings)) {
            deps = depsOrSettings;
          } else {
            hookSettings = depsOrSettings;
            deps = depsOrUndefined;
          }
        }
      }
    }
  } else {
    schema = schemaOrFolderName;

    if (Array.isArray(settingsOrDepsOrSchema)) {
      deps = settingsOrDepsOrSchema;
    } else {
      hookSettings = settingsOrDepsOrSchema;
      deps = depsOrSettingsOrFolderSettings;
    }
  }

  return {
    schema,
    folderName,
    folderSettings,
    hookSettings,
    deps: deps || []
  };
}

function useControls(schemaOrFolderName, settingsOrDepsOrSchema, depsOrSettingsOrFolderSettings, depsOrSettings, depsOrUndefined) {
  const {
    folderName,
    schema,
    folderSettings,
    hookSettings,
    deps
  } = parseArgs(schemaOrFolderName, settingsOrDepsOrSchema, depsOrSettingsOrFolderSettings, depsOrSettings, depsOrUndefined);
  const schemaIsFunction = typeof schema === 'function';
  const depsChanged = useRef(false);
  const firstRender = useRef(true);

  const _schema = useDeepMemo(() => {
    depsChanged.current = true;
    const s = typeof schema === 'function' ? schema() : schema;
    return folderName ? {
      [folderName]: folder(s, folderSettings)
    } : s;
  }, deps);

  const isGlobalPanel = !(hookSettings !== null && hookSettings !== void 0 && hookSettings.store);
  useRenderRoot(isGlobalPanel);
  const [store] = useState(() => (hookSettings === null || hookSettings === void 0 ? void 0 : hookSettings.store) || levaStore);
  const [initialData, mappedPaths] = useMemo(() => store.getDataFromSchema(_schema), [store, _schema]);
  const paths = useMemo(() => store.orderPaths(Object.values(mappedPaths)), [mappedPaths, store]);
  const values = useValuesForPath(store, paths, initialData);
  const set = useCallback(values => {
    const _values = Object.entries(values).reduce((acc, [p, v]) => Object.assign(acc, {
      [mappedPaths[p]]: v
    }), {});

    store.set(_values);
  }, [store, mappedPaths]);
  useEffect(() => {
    const shouldOverrideSettings = !firstRender.current && depsChanged.current;
    store.addData(initialData, shouldOverrideSettings);
    firstRender.current = false;
    depsChanged.current = false;
    return () => store.disposePaths(paths);
  }, [store, paths, initialData]);
  if (schemaIsFunction) return [values, set];
  return values;
}

register('SELECT', select);
register('IMAGE', image);
register('NUMBER', number$1);
register('COLOR', color);
register('STRING', string);
register('BOOLEAN', boolean);
register('INTERVAL', interval);
register('VECTOR3D', vector3d);
register('VECTOR2D', vector2d);

export { Leva, LevaPanel, button, buttonGroup, folder, levaStore, monitor, useControls, useCreateStore };
