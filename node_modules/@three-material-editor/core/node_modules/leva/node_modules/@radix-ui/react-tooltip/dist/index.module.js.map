{"mappings":"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","sources":["./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 300;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 300;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Primitive, extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipProvider, useTooltipContext] = createContext<TooltipContextValue>(TOOLTIP_NAME);\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id: contentId });\n    };\n  }, [contentId]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <TooltipProvider\n      triggerRef={triggerRef}\n      contentId={contentId}\n      open={open}\n      stateAttribute={stateAttribute}\n    >\n      {children}\n    </TooltipProvider>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const { as = TRIGGER_DEFAULT_TAG, ...triggerProps } = props;\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      type=\"button\"\n      aria-describedby={context.open ? context.contentId : undefined}\n      data-state={context.stateAttribute}\n      {...triggerProps}\n      as={as}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.contentId })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.contentId })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('mouseLeft', { id: context.contentId });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.contentId })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('blurred', { id: context.contentId });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.contentId })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.contentId });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Polymorphic.Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        data-state={context.stateAttribute}\n        {...contentProps}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        <Slottable>{children}</Slottable>\n        <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHiddenPrimitive.Root>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'TooltipArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const context = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(context.triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id: context.contentId });\n    }\n  }, [context.contentId, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["restTimerId","skipRestTimerId","stateMachine","stateChart","debug","warnOnUnknownTransitions","PREVIOUS_STATE","PREVIOUS_CONTEXT","CURRENT_STATE","initial","CURRENT_CONTEXT","context","subscriptions","transition","event","stateDefinition","states","nextState","on","undefined","console","warn","concat","onLeaveState","nextStateDefinition","onEnterState","log","previousState","previousContext","state","forEach","callback","subscribe","push","splice","indexOf","getState","getContext","$e37f874ef74368da320cbbbb439$export$createStateMachine","id","CLOSED","mouseEntered","focused","WAITING_FOR_REST","clearTimeout","window","setTimeout","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerElapsed","DISMISSED","TooltipProvider","useTooltipContext","createContext","Tooltip","props","children","open","openProp","defaultOpen","onOpenChange","triggerRef","React","useRef","contentId","useId","setOpen","useControllableState","prop","defaultProp","onChange","stateAttribute","setStateAttribute","useState","useEffect","useLayoutEffect","_react","createElement","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipProvider","displayName","TRIGGER_DEFAULT_TAG","TooltipTrigger","forwardRef","forwardedRef","as","triggerProps","composedTriggerRef","useComposedRefs","Primitive","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$_extends","type","aria-describedby","data-state","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","key","TooltipContent","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContentImpl","TooltipContentImpl","aria-label","ariaLabel","anchorRef","portalled","contentProps","PortalWrapper","Portal","Fragment","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$CheckTriggerMoved","_radixUiReactPopper","Root","style","--radix-tooltip-content-transform-origin","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","extendPrimitive","PopperPrimitive","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.module.js.map"}