{"mappings":"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","sources":["./packages/core/popper/src/popper.ts"],"sourcesContent":["import * as CSS from 'csstype';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Axis = 'x' | 'y';\ntype Side = typeof SIDE_OPTIONS[number];\ntype Align = typeof ALIGN_OPTIONS[number];\ntype Point = { x: number; y: number };\ntype Size = { width: number; height: number };\n\ntype GetPlacementDataOptions = {\n  /** The rect of the anchor we are placing around */\n  anchorRect?: ClientRect;\n  /** The size of the popper to place */\n  popperSize?: Size;\n  /** An optional arrow size */\n  arrowSize?: Size;\n  /** An optional arrow offset (along the side, default: 0) */\n  arrowOffset?: number;\n  /** The desired side */\n  side: Side;\n  /** An optional side offset (distance from the side, default: 0)  */\n  sideOffset?: number;\n  /** The desired alignment */\n  align: Align;\n  /** An optional alignment offset (distance along the side, default: 0) */\n  alignOffset?: number;\n  /** An option to turn on/off the collision handling (default: true) */\n  shouldAvoidCollisions?: boolean;\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect?: ClientRect;\n  /** The tolerance used for collisions, ie. if we want them to trigger a bit earlier (default: 0) */\n  collisionTolerance?: number;\n};\n\ntype PlacementData = {\n  popperStyles: CSS.Properties;\n  arrowStyles: CSS.Properties;\n  placedSide?: Side;\n  placedAlign?: Align;\n};\n\n/**\n * Given all the information necessary to compute it,\n * this function calculates all the necessary placement data.\n *\n * It will return:\n *\n * - the styles to apply to the popper (including a custom property that is useful to set the transform origin in the right place)\n * - the styles to apply to the arrow\n * - the placed side (because it might have changed because of collisions)\n * - the placed align (because it might have changed because of collisions)\n */\nfunction getPlacementData({\n  anchorRect,\n  popperSize,\n  arrowSize,\n  arrowOffset = 0,\n  side,\n  sideOffset = 0,\n  align,\n  alignOffset = 0,\n  shouldAvoidCollisions = true,\n  collisionBoundariesRect,\n  collisionTolerance = 0,\n}: GetPlacementDataOptions): PlacementData {\n  // if we're not ready to do all the measurements yet,\n  // we return some good default styles\n  if (!anchorRect || !popperSize || !collisionBoundariesRect) {\n    return {\n      popperStyles: UNMEASURED_POPPER_STYLES,\n      arrowStyles: UNMEASURED_ARROW_STYLES,\n    };\n  }\n\n  // pre-compute points for all potential placements\n  const allPlacementPoints = getAllPlacementPoints(\n    popperSize,\n    anchorRect,\n    sideOffset,\n    alignOffset,\n    arrowSize\n  );\n\n  // get point based on side / align\n  const popperPoint = allPlacementPoints[side][align];\n\n  // if we don't need to avoid collisions, we can stop here\n  if (shouldAvoidCollisions === false) {\n    const popperStyles = getPlacementStylesForPoint(popperPoint);\n\n    let arrowStyles = UNMEASURED_ARROW_STYLES;\n    if (arrowSize) {\n      arrowStyles = getPopperArrowStyles({ popperSize, arrowSize, arrowOffset, side, align });\n    }\n\n    const transformOrigin = getTransformOrigin(popperSize, side, align, arrowOffset, arrowSize);\n\n    return {\n      popperStyles: {\n        ...popperStyles,\n        ['--radix-popper-transform-origin' as any]: transformOrigin,\n      },\n      arrowStyles,\n      placedSide: side,\n      placedAlign: align,\n    };\n  }\n\n  // create a new rect as if element had been moved to new placement\n  const popperRect = DOMRect.fromRect({ ...popperSize, ...popperPoint });\n\n  // create a new rect representing the collision boundaries but taking into account any added tolerance\n  const collisionBoundariesRectWithTolerance = getContractedRect(\n    collisionBoundariesRect,\n    collisionTolerance\n  );\n\n  // check for any collisions in new placement\n  const popperCollisions = getCollisions(popperRect, collisionBoundariesRectWithTolerance);\n\n  // do all the same calculations for the opposite side\n  // this is because we need to check for potential collisions if we were to swap side\n  const oppositeSide = getOppositeSide(side);\n  const oppositeSidePopperPoint = allPlacementPoints[oppositeSide][align];\n  const updatedOppositeSidePopperPoint = DOMRect.fromRect({\n    ...popperSize,\n    ...oppositeSidePopperPoint,\n  });\n  const oppositeSidePopperCollisions = getCollisions(\n    updatedOppositeSidePopperPoint,\n    collisionBoundariesRectWithTolerance\n  );\n\n  // adjust side accounting for collisions / opposite side collisions\n  const placedSide = getSideAccountingForCollisions(\n    side,\n    popperCollisions,\n    oppositeSidePopperCollisions\n  );\n\n  // adjust alignnment accounting for collisions\n  const placedAlign = getAlignAccountingForCollisions(\n    popperSize,\n    anchorRect,\n    side,\n    align,\n    popperCollisions\n  );\n\n  const placedPopperPoint = allPlacementPoints[placedSide][placedAlign];\n\n  // compute adjusted popper / arrow styles\n  const popperStyles = getPlacementStylesForPoint(placedPopperPoint);\n\n  let arrowStyles = UNMEASURED_ARROW_STYLES;\n  if (arrowSize) {\n    arrowStyles = getPopperArrowStyles({\n      popperSize,\n      arrowSize,\n      arrowOffset,\n      side: placedSide,\n      align: placedAlign,\n    });\n  }\n\n  const transformOrigin = getTransformOrigin(\n    popperSize,\n    placedSide,\n    placedAlign,\n    arrowOffset,\n    arrowSize\n  );\n\n  return {\n    popperStyles: {\n      ...popperStyles,\n      ['--radix-popper-transform-origin' as any]: transformOrigin,\n    },\n    arrowStyles,\n    placedSide,\n    placedAlign,\n  };\n}\n\ntype AllPlacementPoints = Record<Side, Record<Align, Point>>;\n\nfunction getAllPlacementPoints(\n  popperSize: Size,\n  anchorRect: ClientRect,\n  sideOffset: number = 0,\n  alignOffset: number = 0,\n  arrowSize?: Size\n): AllPlacementPoints {\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n\n  const x = getPopperSlotsForAxis(anchorRect, popperSize, 'x');\n  const y = getPopperSlotsForAxis(anchorRect, popperSize, 'y');\n\n  const topY    = y.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const bottomY = y.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n  const leftX   = x.before - sideOffset - arrowBaseToTipLength; // prettier-ignore\n  const rightX  = x.after  + sideOffset + arrowBaseToTipLength; // prettier-ignore\n\n  // prettier-ignore\n  const map: AllPlacementPoints = {\n    top: {\n      start:  { x: x.start + alignOffset, y: topY },\n      center: { x: x.center,              y: topY },\n      end:    { x: x.end - alignOffset,   y: topY },\n    },\n    right: {\n      start:  { x: rightX, y: y.start + alignOffset },\n      center: { x: rightX, y: y.center },\n      end:    { x: rightX, y: y.end - alignOffset },\n    },\n    bottom: {\n      start:  { x: x.start + alignOffset, y: bottomY },\n      center: { x: x.center,              y: bottomY },\n      end:    { x: x.end - alignOffset,   y: bottomY },\n    },\n    left: {\n      start:  { x: leftX, y: y.start + alignOffset },\n      center: { x: leftX, y: y.center },\n      end:    { x: leftX, y: y.end - alignOffset },\n    },\n  };\n\n  return map;\n}\n\nfunction getPopperSlotsForAxis(anchorRect: ClientRect, popperSize: Size, axis: Axis) {\n  const startSide = axis === 'x' ? 'left' : 'top';\n  const anchorStart = anchorRect[startSide];\n\n  const dimension = axis === 'x' ? 'width' : 'height';\n  const anchorDimension = anchorRect[dimension];\n  const popperDimension = popperSize[dimension];\n\n  // prettier-ignore\n  return {\n    before: anchorStart - popperDimension,\n    start:  anchorStart,\n    center: anchorStart + (anchorDimension - popperDimension) / 2,\n    end:    anchorStart + anchorDimension - popperDimension,\n    after:  anchorStart + anchorDimension,\n  };\n}\n\n/**\n * Gets an adjusted side based on collision information\n */\nfunction getSideAccountingForCollisions(\n  /** The side we want to ideally position to */\n  side: Side,\n  /** The collisions for this given side */\n  collisions: Collisions,\n  /** The collisions for the opposite side (if we were to swap side) */\n  oppositeSideCollisions: Collisions\n): Side {\n  const oppositeSide = getOppositeSide(side);\n  // in order to prevent premature jumps\n  // we only swap side if there's enough space to fit on the opposite side\n  return collisions[side] && !oppositeSideCollisions[oppositeSide] ? oppositeSide : side;\n}\n\n/**\n * Gets an adjusted alignment based on collision information\n */\nfunction getAlignAccountingForCollisions(\n  /** The size of the popper to place */\n  popperSize: Size,\n  /** The size of the anchor we are placing around */\n  anchorSize: Size,\n  /** The final side */\n  side: Side,\n  /** The desired align */\n  align: Align,\n  /** The collisions */\n  collisions: Collisions\n): Align {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n  const startBound = isHorizontalSide ? 'left' : 'top';\n  const endBound = isHorizontalSide ? 'right' : 'bottom';\n  const dimension = isHorizontalSide ? 'width' : 'height';\n  const isAnchorBigger = anchorSize[dimension] > popperSize[dimension];\n\n  if (align === 'start' || align === 'center') {\n    if ((collisions[startBound] && isAnchorBigger) || (collisions[endBound] && !isAnchorBigger)) {\n      return 'end';\n    }\n  }\n\n  if (align === 'end' || align === 'center') {\n    if ((collisions[endBound] && isAnchorBigger) || (collisions[startBound] && !isAnchorBigger)) {\n      return 'start';\n    }\n  }\n\n  return align;\n}\n\nfunction getPlacementStylesForPoint(point: Point): CSS.Properties {\n  const x = Math.round(point.x + window.scrollX);\n  const y = Math.round(point.y + window.scrollY);\n  return {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    minWidth: 'max-content',\n    willChange: 'transform',\n    transform: `translate3d(${x}px, ${y}px, 0)`,\n  };\n}\n\nfunction getTransformOrigin(\n  popperSize: Size,\n  side: Side,\n  align: Align,\n  arrowOffset: number,\n  arrowSize?: Size\n): CSS.Properties['transformOrigin'] {\n  const isHorizontalSide = side === 'top' || side === 'bottom';\n\n  const arrowBaseLength = arrowSize ? arrowSize.width : 0;\n  const arrowBaseToTipLength = arrowSize ? arrowSize.height : 0;\n  const sideOffset = arrowBaseToTipLength;\n  const alignOffset = arrowBaseLength / 2 + arrowOffset;\n\n  let x = '';\n  let y = '';\n\n  if (isHorizontalSide) {\n    x = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.width - alignOffset}px`,\n    }[align];\n\n    y = side === 'top' ? `${popperSize.height + sideOffset}px` : `${-sideOffset}px`;\n  } else {\n    x = side === 'left' ? `${popperSize.width + sideOffset}px` : `${-sideOffset}px`;\n\n    y = {\n      start: `${alignOffset}px`,\n      center: 'center',\n      end: `${popperSize.height - alignOffset}px`,\n    }[align];\n  }\n\n  return `${x} ${y}`;\n}\n\nconst UNMEASURED_POPPER_STYLES: CSS.Properties = {\n  // position: 'fixed' here is important because it will take the popper\n  // out of the flow so it does not disturb the position of the anchor\n  position: 'fixed',\n  top: 0,\n  left: 0,\n  opacity: 0,\n  pointerEvents: 'none',\n};\n\nconst UNMEASURED_ARROW_STYLES: CSS.Properties = {\n  // given the arrow is nested inside the popper,\n  // make sure that it is out of the flow and doesn't hinder then popper's measurement\n  position: 'absolute',\n  opacity: 0,\n};\n\ntype GetArrowStylesOptions = {\n  /** The size of the popper to place */\n  popperSize: Size;\n  /** The size of the arrow itself */\n  arrowSize: Size;\n  /** An offset for the arrow along the align axis */\n  arrowOffset: number;\n  /** The side where the arrow points to */\n  side: Side;\n  /** The alignment of the arrow along the side */\n  align: Align;\n};\n\n/**\n * Computes the styles necessary to position, rotate and align the arrow correctly.\n * It can adjust itself based on anchor/popper size, side/align and an optional offset.\n */\nfunction getPopperArrowStyles({\n  popperSize,\n  arrowSize,\n  arrowOffset,\n  side,\n  align,\n}: GetArrowStylesOptions): CSS.Properties {\n  const popperCenterX = (popperSize.width - arrowSize.width) / 2;\n  const popperCenterY = (popperSize.height - arrowSize.width) / 2;\n\n  const rotationMap = { top: 0, right: 90, bottom: 180, left: -90 };\n  const rotation = rotationMap[side];\n  const arrowMaxDimension = Math.max(arrowSize.width, arrowSize.height);\n\n  const styles: CSS.Properties = {\n    // we make sure we put the arrow inside a 1:1 ratio container\n    // this is to make the rotation handling simpler\n    // as we do no need to worry about changing the transform-origin\n    width: `${arrowMaxDimension}px`,\n    height: `${arrowMaxDimension}px`,\n\n    // rotate the arrow appropriately\n    transform: `rotate(${rotation}deg)`,\n    willChange: 'transform',\n\n    // position the arrow appropriately\n    position: 'absolute',\n    [side]: '100%',\n\n    // Because the arrow gets rotated (see `transform above`)\n    // and we are putting it inside a 1:1 ratio container\n    // we need to adjust the CSS direction from `ltr` to `rtl`\n    // in some circumstances\n    direction: getArrowCssDirection(side, align),\n  };\n\n  if (side === 'top' || side === 'bottom') {\n    if (align === 'start') {\n      styles.left = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.left = `${popperCenterX}px`;\n    }\n    if (align === 'end') {\n      styles.right = `${arrowOffset}px`;\n    }\n  }\n\n  if (side === 'left' || side === 'right') {\n    if (align === 'start') {\n      styles.top = `${arrowOffset}px`;\n    }\n    if (align === 'center') {\n      styles.top = `${popperCenterY}px`;\n    }\n    if (align === 'end') {\n      styles.bottom = `${arrowOffset}px`;\n    }\n  }\n\n  return styles;\n}\n\n/**\n * Adjusts the arrow's CSS direction (`ltr` / `rtl`)\n */\nfunction getArrowCssDirection(side: Side, align: Align): CSS.Property.Direction {\n  if ((side === 'top' || side === 'right') && align === 'end') {\n    return 'rtl';\n  }\n\n  if ((side === 'bottom' || side === 'left') && align !== 'end') {\n    return 'rtl';\n  }\n\n  return 'ltr';\n}\n\n/**\n * Gets the opposite side of a given side (ie. top => bottom, left => right, …)\n */\nfunction getOppositeSide(side: Side): Side {\n  const oppositeSides: Record<Side, Side> = {\n    top: 'bottom',\n    right: 'left',\n    bottom: 'top',\n    left: 'right',\n  };\n  return oppositeSides[side];\n}\n\n/**\n * Creates a new rect (`ClientRect`) based on a given one but contracted by\n * a given amout on each side.\n */\nfunction getContractedRect(rect: ClientRect, amount: number) {\n  return DOMRect.fromRect({\n    width: rect.width - amount * 2,\n    height: rect.height - amount * 2,\n    x: rect.left + amount,\n    y: rect.top + amount,\n  });\n}\n\n/**\n * Gets collisions for each side of a rect (top, right, bottom, left)\n */\nfunction getCollisions(\n  /** The rect to test collisions against */\n  rect: ClientRect,\n  /** The rect which represents the boundaries for collision checks */\n  collisionBoundariesRect: ClientRect\n) {\n  return {\n    top: rect.top < collisionBoundariesRect.top,\n    right: rect.right > collisionBoundariesRect.right,\n    bottom: rect.bottom > collisionBoundariesRect.bottom,\n    left: rect.left < collisionBoundariesRect.left,\n  };\n}\n\ntype Collisions = ReturnType<typeof getCollisions>;\n\nexport { getPlacementData, SIDE_OPTIONS, ALIGN_OPTIONS };\nexport type { Side, Align };\n"],"names":["getPopperSlotsForAxis","anchorRect","popperSize","axis","anchorStart","dimension","anchorDimension","popperDimension","before","start","center","end","after","getPlacementStylesForPoint","point","x","Math","round","window","scrollX","y","scrollY","position","top","left","minWidth","willChange","transform","concat","getTransformOrigin","side","align","arrowOffset","arrowSize","isHorizontalSide","arrowBaseLength","width","sideOffset","height","alignOffset","_ref","_ref$arrowOffset","_ref$sideOffset","_ref$alignOffset","_ref$shouldAvoidColli","shouldAvoidCollisions","collisionBoundariesRect","_ref$collisionToleran","collisionTolerance","popperStyles","UNMEASURED_POPPER_STYLES","arrowStyles","UNMEASURED_ARROW_STYLES","allPlacementPoints","arguments","length","undefined","arrowBaseToTipLength","topY","bottomY","leftX","rightX","right","bottom","getAllPlacementPoints","popperPoint","getPopperArrowStyles","transformOrigin","$ba85c0af668235e79eb20a6ca9db8a72$var$_objectSpread","$ba85c0af668235e79eb20a6ca9db8a72$var$_defineProperty","placedSide","placedAlign","rect","amount","popperRect","DOMRect","fromRect","collisionBoundariesRectWithTolerance","popperCollisions","getCollisions","oppositeSidePopperPoint","getOppositeSide","collisions","oppositeSideCollisions","oppositeSide","getSideAccountingForCollisions","anchorSize","startBound","endBound","isAnchorBigger","getAlignAccountingForCollisions","opacity","pointerEvents","_ref2","_styles","popperCenterX","popperCenterY","rotation","arrowMaxDimension","max","styles","getArrowCssDirection"],"version":3,"file":"index.js.map"}