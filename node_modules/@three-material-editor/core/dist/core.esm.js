import React, { useState, useEffect, useRef, useLayoutEffect } from 'react';
import { proxy, useProxy } from 'valtio';
import { devtools } from 'valtio/utils';
import { ShaderChunk, ShaderLib, Color, TextureLoader, RepeatWrapping, Vector2, Mesh, MeshBasicMaterial, FrontSide } from 'three';
import Editor, { loader, DiffEditor } from '@monaco-editor/react';
import { IoImageOutline, IoCubeOutline, IoCloseOutline, IoEyeOffOutline, IoEyeOutline } from 'react-icons/io5';
import { useDrag } from 'react-use-gesture';
import { RiArrowDownSFill, RiArrowRightSFill } from 'react-icons/ri';
import { VscSettings, VscCompareChanges } from 'react-icons/vsc';
import { AiOutlineFullscreen, AiOutlineFunction } from 'react-icons/ai';
import { BiDockRight, BiEraser } from 'react-icons/bi';
import { BsArrowBarRight, BsArrowBarLeft } from 'react-icons/bs';
import { HiOutlineClipboardCopy } from 'react-icons/hi';
import { Leva, LevaPanel, useCreateStore, useControls } from 'leva';
import { createPortal } from 'react-dom';

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "\n.editor-module_colorf__2lhnn {\n  color: rgb(120, 220, 232);\n}\n.editor-module_colorv__31zS_ {\n  color: rgb(252, 152, 103);\n}\n\n.editor-module_editor_c__16HRX {\n  --editor-menu-width: 240px;\n  --editor-width: 520px;\n  --editor-minus-height: 0px;\n\n  position: fixed;\n  top: 0;\n  right: 0;\n  z-index: 999;\n\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n  'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n  sans-serif;\n  color: #fff;\n  margin: 0;\n  padding: 4px 6px;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n\n.editor-module_editor__1MUvb {\n  position: fixed;\n  top: 0;\n  right: 0;\n  z-index: 999;\n  background-color: rgba(36,36,36,1);\n  height: min(100vh, max(120px, calc(100% - var(--editor-minus-height))));\n  padding-top: 28px;\n  width: min(calc(100vw - 160px), var(--editor-width)) !important;\n  transition: width .3s cubic-bezier(0.075, 0.82, 0.165, 1), height .3s cubic-bezier(0.075, 0.82, 0.165, 1);\n}\n.editor-module_editor__1MUvb svg {\n  display: inline-block;\n  vertical-align: initial;\n}\n.editor-module_editor__1MUvb *, .editor-module_editor__1MUvb *::after, .editor-module_editor__1MUvb *::before {\n  box-sizing: border-box;\n}\n.editor-module_editor_c__16HRX.editor-module_full__2cjlZ {\n  width: calc(100% - var(--editor-menu-width));\n  height: 100%;\n}\n.editor-module_editor_c__16HRX.editor-module_full__2cjlZ .editor-module_editor__1MUvb {\n  width: calc(100% - var(--editor-menu-width)) !important;\n  height: 100%;\n}\n\n.editor-module_editor_h__MRECc {\n  --editor-width: 0px !important;\n}\n.editor-module_editor__1MUvb * {\n  font-family: inherit;\n}\n.editor-module_editor__1MUvb.editor-module_top-left__1Lf1m {\n  right: initial;\n  left: 0;\n}\n\n.editor-module_editor__1MUvb.editor-module_bottom-left__1W_R- {\n  right: initial;\n  top: initial;\n  bottom: 0;\n  left: 0;\n}\n.editor-module_editor__1MUvb.editor-module_bottom-right__2VkdP {\n  top: initial;\n  bottom: 0;\n}\n.editor-module_embed__2iwnO {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n.editor-module_embed__2iwnO > svg {\n  display: none;\n  position: absolute;\n  top: 8px;\n  left: 10px;\n}\n.editor-module_embedfull__9UVqb {\n  position: fixed;\n  z-index: 1000;\n  top: initial;\n  left: initial;\n  /* pointer-events: none; */\n  right: 14px;\n  bottom: 14px;\n  box-shadow: 0px 8px 28px rgb(0 0 0 / 25%), 0 10px 10px rgb(0 0 0 / 22%);\n\n  width: 70% !important;\n  height: auto !important;\n  max-width: 800px !important;\n  max-height: 620px !important;\n}\n.editor-module_embedfull__9UVqb canvas {\n  width: 100% !important;\n  height: 100% !important;\n}\n.editor-module_embedfull__9UVqb > svg {\n  display: block;\n}\n.editor-module_embedglass__2BjeI {\n  position: absolute;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  top: 0;\n  -webkit-backdrop-filter: blur(10px);\n          backdrop-filter: blur(10px);\n  z-index: -1;\n}";
var styles = {"colorf":"editor-module_colorf__2lhnn","colorv":"editor-module_colorv__31zS_","editor_c":"editor-module_editor_c__16HRX","editor":"editor-module_editor__1MUvb","full":"editor-module_full__2cjlZ","editor_h":"editor-module_editor_h__MRECc","top-left":"editor-module_top-left__1Lf1m","bottom-left":"editor-module_bottom-left__1W_R-","bottom-right":"editor-module_bottom-right__2VkdP","embed":"editor-module_embed__2iwnO","embedfull":"editor-module_embedfull__9UVqb","embedglass":"editor-module_embedglass__2BjeI"};
styleInject(css_248z);

var editorState = /*#__PURE__*/proxy({
  className: '',
  showMenu: false,
  showEditor: false,
  showUniforms: false,
  fullScreen: true,
  diffMode: false,
  obcMode: false,
  length: 0,
  triggerUpdate: 0,
  scene: null,
  composer: null,
  materials: [],
  diagnostics: {},
  tabs: {},
  activeMaterial: {
    type: '',
    open: false,
    model: null,
    cachedModel: null,
    isModif: false,
    cache: {
      vert: '',
      frag: ''
    }
  }
});
devtools(editorState, 'material editor');
var editorContextState = {
  materials: {},
  activeMaterialRef: {},
  programs: [],
  editorWidth: 520,
  editorMinusHeight: 0,
  gl: null
};

/**
 * Regular expression for matching the `void main() {` opener line in GLSL.
 * @type {RegExp}
 */
var commentedIncludeRegExp = /^(\s*)\/\/ #include <([a-zA-Z0-9_]+)>/gm;
var includeRegExp = /^(\s*)#include <([a-zA-Z0-9_]+)>/gm;

var replaceShaderChunks = function replaceShaderChunks(code) {
  if (typeof code !== 'string') {
    return;
  }

  var format = code.replaceAll(includeRegExp, function (_substring, _indent, name) {
    var chunk = ShaderChunk[name];
    chunk = chunk.split('\n').map(function (line) {
      return line;
    }).join("\n\t");
    return "// #include <" + name + ">\n\t" + chunk + "\n//\n";
  });
  return format;
};

var _formatToObc = function _formatToObc(code) {
  if (typeof code !== 'string') {
    return;
  }

  var resetIncludes = code.replaceAll(commentedIncludeRegExp, function (_substring, _indent, name) {
    return "#include <" + name + ">";
  }).trim();
  var result = resetIncludes.split(includeRegExp);
  var filtered = result.filter(function (el) {
    return el !== '';
  });
  return filtered;
};
var generateOBc = function generateOBc(_code) {
  var model = editorState.activeMaterial.cachedModel;
  var type = editorState.activeMaterial.type === 'frag' ? 'fragmentShader' : 'vertexShader';
  var oModel = editorContext.monacoRef.editor.getModel(model + '_orig').getValue();
  var mModel = editorContext.monacoRef.editor.getModel(model).getValue();

  var base = _formatToObc(oModel);

  var edited = _formatToObc(mModel);

  var result = new Map();

  if (!base || !edited) {
    return '';
  }

  for (var index = 0; index < base.length; index++) {
    var b = base[index];
    var e = edited[index];

    if (b !== e) {
      result.set(edited[index - 1], e);
    }
  }

  var onBeforeCompileFunction = "// generated using three-material-editor\nmaterial.onBeforeCompile = (shader) => {\n";
  result.forEach(function (value, key) {
    // minify
    var valueFormated = value.length > 500 ? value.trim().replace(/(\r\n|\n|\r)/gm, '') : value;
    onBeforeCompileFunction += (value.length > 500 ? '\t// > 500 characters - auto minified\n' : '') + "\tshader." + type + " = shader." + type + ".replace(`#include <" + key + ">`, `" + valueFormated + " `);\n";
  });
  onBeforeCompileFunction += "}\n";
  editorState.obcMode = true;
  editorState.triggerUpdate++;
  return onBeforeCompileFunction;
};

var conf = {
  comments: {
    lineComment: '//',
    blockComment: ['/*', '*/']
  },
  brackets: [['{', '}'], ['[', ']'], ['(', ')']],
  autoClosingPairs: [{
    open: '[',
    close: ']'
  }, {
    open: '{',
    close: '}'
  }, {
    open: '(',
    close: ')'
  }, {
    open: "'",
    close: "'",
    notIn: ['string', 'comment']
  }, {
    open: '"',
    close: '"',
    notIn: ['string']
  }],
  surroundingPairs: [{
    open: '{',
    close: '}'
  }, {
    open: '[',
    close: ']'
  }, {
    open: '(',
    close: ')'
  }, {
    open: '"',
    close: '"'
  }, {
    open: "'",
    close: "'"
  }],
  folding: {
    markers: {
      start: /*#__PURE__*/new RegExp('^\\s*#pragma\\s+region\\b'),
      end: /*#__PURE__*/new RegExp('^\\s*#pragma\\s+endregion\\b')
    }
  }
};
var language = {
  defaultToken: '',
  tokenPostfix: '.cpp',
  brackets: [{
    token: 'delimiter.curly',
    open: '{',
    close: '}'
  }, {
    token: 'delimiter.parenthesis',
    open: '(',
    close: ')'
  }, {
    token: 'delimiter.square',
    open: '[',
    close: ']'
  }, {
    token: 'delimiter.angle',
    open: '<',
    close: '>'
  }],
  keywords: ['discard', 'length', 'smoothstep', 'uniform', 'precision', 'mediump', 'highp', 'vec2', 'vec3', 'vec4', 'ivec2', 'ivec3', 'ivec4', 'abstract', 'amp', 'array', 'auto', 'bool', 'break', 'case', 'catch', 'char', 'class', 'const', 'gl_FragColor', 'constexpr', 'const_cast', 'continue', 'cpu', 'decltype', 'default', 'delegate', 'delete', 'do', 'double', 'dynamic_cast', 'each', 'else', 'enum', 'event', 'explicit', 'export', 'extern', 'false', 'final', 'finally', 'float', 'for', 'friend', 'gcnew', 'generic', 'goto', 'if', 'in', 'initonly', 'inline', 'int', 'interface', 'interior_ptr', 'internal', 'literal', 'long', 'mutable', 'namespace', 'new', 'noexcept', 'nullptr', '__nullptr', 'operator', 'override', 'partial', 'pascal', 'pin_ptr', 'private', 'property', 'protected', 'public', 'ref', 'register', 'reinterpret_cast', 'restrict', 'return', 'safe_cast', 'sealed', 'short', 'signed', 'sizeof', 'static', 'static_assert', 'static_cast', 'struct', 'switch', 'template', 'this', 'thread_local', 'throw', 'tile_static', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned', 'using', 'virtual', 'void', 'volatile', 'wchar_t', 'where', 'while'],
  typeKeywords: /*#__PURE__*/'float int bool void\nvec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4\nmat2 mat3 mat4\nsampler2D sampler3D samplerCube\nconst attribute uniform varying'.split(/\s+/),
  operators: ['=', '>', '<', '!', '~', '?', ':', '==', '<=', '>=', '!=', '&&', '||', '++', '--', '+', '-', '*', '/', '&', '|', '^', '%', '<<', '>>', '>>>', '+=', '-=', '*=', '/=', '&=', '|=', '^=', '%=', '<<=', '>>=', '>>>='],
  // we include these common regular expressions
  symbols: /[=><!~?:&|+\-*/^%]+/,
  escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
  integersuffix: /(ll|LL|u|U|l|L)?(ll|LL|u|U|l|L)?/,
  floatsuffix: /[fFlL]?/,
  encoding: /u|u8|U|L/,
  // The main tokenizer for our languages
  tokenizer: {
    root: [// C++ 11 Raw String
    [/@encoding?R"(?:([^ ()\\\t]*))\(/, {
      token: 'string.raw.begin',
      next: '@raw.$1'
    }], // identifiers and keywords
    [/[a-z_$][\w$]*/, {
      cases: {
        '@typeKeywords': 'keyword',
        '@keywords': 'keyword',
        '@default': 'identifier'
      }
    }], [/[A-Z][\w$]*/, 'type.identifier'], // whitespace
    {
      include: '@whitespace'
    }, // [[ attributes ]].
    [/\[\[.*\]\]/, 'annotation'], [/^\s*#include/, {
      token: 'keyword.directive.include',
      next: '@include'
    }], // Preprocessor directive
    [/^\s*#\s*\w+/, 'keyword'], // delimiters and operators
    [/[{}()[\]]/, '@brackets'], [/[<>](?!@symbols)/, '@brackets'], [/@symbols/, {
      cases: {
        '@operators': 'delimiter',
        '@default': ''
      }
    }], // numbers
    [/\d*\d+[eE]([-+]?\d+)?(@floatsuffix)/, 'number.float'], [/\d*\.\d+([eE][-+]?\d+)?(@floatsuffix)/, 'number.float'], [/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/, 'number.hex'], [/0[0-7']*[0-7](@integersuffix)/, 'number.octal'], [/0[bB][0-1']*[0-1](@integersuffix)/, 'number.binary'], [/\d[\d']*\d(@integersuffix)/, 'number'], [/\d(@integersuffix)/, 'number'], // delimiter: after number because of .\d floats
    [/[;,.]/, 'delimiter'], // strings
    [/"([^"\\]|\\.)*$/, 'string.invalid'], [/"/, 'string', '@string'], // characters
    [/'[^\\']'/, 'string'], [/(')(@escapes)(')/, ['string', 'string.escape', 'string']], [/'/, 'string.invalid']],
    whitespace: [[/[ \t\r\n]+/, ''], [/\/\*\*(?!\/)/, 'comment.doc', '@doccomment'], [/\/\*/, 'comment', '@comment'], [/\/\/.*$/, 'comment']],
    comment: [[/[^/*]+/, 'comment'], [/\*\//, 'comment', '@pop'], [/[/*]/, 'comment']],
    //Identical copy of comment above, except for the addition of .doc
    doccomment: [[/[^/*]+/, 'comment.doc'], [/\*\//, 'comment.doc', '@pop'], [/[/*]/, 'comment.doc']],
    string: [[/[^\\"]+/, 'string'], [/@escapes/, 'string.escape'], [/\\./, 'string.escape.invalid'], [/"/, 'string', '@pop']],
    raw: [[/(.*)(\))(?:([^ ()\\\t]*))(")/, {
      cases: {
        '$3==$S2': ['string.raw', 'string.raw.end', 'string.raw.end', {
          token: 'string.raw.end',
          next: '@pop'
        }],
        '@default': ['string.raw', 'string.raw', 'string.raw', 'string.raw']
      }
    }], [/.*/, 'string.raw']],
    include: [[/(\s*)(<)([^<>]*)(>)/, ['', 'keyword.directive.include.begin', 'string.include.identifier', {
      token: 'keyword.directive.include.end',
      next: '@pop'
    }]], [/(\s*)(")([^"]*)(")/, ['', 'keyword.directive.include.begin', 'string.include.identifier', {
      token: 'keyword.directive.include.end',
      next: '@pop'
    }]]]
  }
};

var css_248z$1 = ".tabs-module_tabs__200e9 {\n  position: fixed;\n  top: 0;\n  right: 0;\n  z-index: 1000;\n  background: rgb(68 68 68);\n  color: #ccc;\n  padding: 0;\n  text-align: center;\n  font-size: 13px;\n  display: flex;\n  width: var(--editor-width);\n  overflow-x: auto;\n}\n.tabs-module_tabs__200e9.tabs-module_full__2aFRA {\n  width: calc(100% - var(--editor-menu-width));\n}\n.tabs-module_tabs__200e9 > div {\n  cursor: pointer;\n  display: flex;\n}\n.tabs-module_tabs__200e9 > div > div{\n  padding: 7px 7px;\n  display: inline-flex;\n  line-height: 10px;\n  border-right: 1px solid #37383a;\n}\n.tabs-module_tabs__200e9 svg {\n  font-size: 14px;\n  margin: 0 4px;\n}\n.tabs-module_tactive__1bB_x {\n  background: rgb(31,31,31);\n  color: #fff;\n}";
var styles$1 = {"tabs":"tabs-module_tabs__200e9","full":"tabs-module_full__2aFRA","tactive":"tabs-module_tactive__1bB_x"};
styleInject(css_248z$1);

var EditorTabs = function EditorTabs() {
  var snapshot = useProxy(editorState);

  var setActive = function setActive(value) {
    if (editorState.obcMode || editorState.diffMode) {
      editorState.activeMaterial.model = editorState.activeMaterial.cachedModel;
      editorState.activeMaterial.cachedModel = null;
      editorState.diffMode = false;
      editorState.obcMode = false;
      editorState.triggerUpdate++;
    } else {
      editorState.activeMaterial = value;
    }

    checkIfModifications();
  };

  var closeTab = function closeTab(key) {
    delete editorState.tabs[key];

    if (Object.keys(editorState.tabs).length === 0) {
      editorState.obcMode = false;
      editorState.diffMode = false;
      editorState.triggerUpdate++;
      return;
    }

    var lastKey = Object.keys(editorState.tabs).pop();

    if (lastKey) {
      editorState.activeMaterial = editorState.tabs[lastKey];
    }
  };

  return /*#__PURE__*/React.createElement("div", {
    className: styles$1.tabs + " " + (snapshot.showEditor && snapshot.fullScreen ? styles$1.full : '')
  }, Object.entries(snapshot.tabs).map(function (_ref) {
    var key = _ref[0],
        value = _ref[1];
    var name = value.model.replace('urn:', '');
    return /*#__PURE__*/React.createElement("div", {
      key: key
    }, /*#__PURE__*/React.createElement("div", {
      className: key === snapshot.activeMaterial.model ? styles$1.tactive : '',
      onClick: function onClick() {
        setActive(value);
      }
    }, value.type === 'frag' ? /*#__PURE__*/React.createElement(IoImageOutline, {
      className: styles.colorf
    }) : /*#__PURE__*/React.createElement(IoCubeOutline, {
      className: styles.colorv
    }), ' ', "" + name, ' ', /*#__PURE__*/React.createElement(IoCloseOutline, {
      onClick: function onClick() {
        return closeTab(value.model);
      }
    })));
  }));
};

var css_248z$2 = ".menu-module_menu__3tJFo {\n  --sizes-controlWidth: initial;\n  --colors-elevation1: #292b2d;\n  --colors-elevation2: #292b2d;\n  --colors-leva__elevation2: #292b2d;\n  position: fixed;\n  z-index: 999;\n  transform: translateX(calc(min(calc(100vw - 160px), var(--editor-width)) * -1 - 100% + 7px));\n  top: 0;\n  background-color: rgb(41, 43, 45);\n  color: rgba(145,145,145,1);\n  font-size: 13px;\n  padding: 5px 0;\n  min-width: 240px;\n  cursor: nesw-resize;\n  height: min(100vh, max(120px, calc(100% - var(--editor-minus-height))));\n  overflow: hidden;\n  padding-bottom: 23px;\n  transition: transform .3s cubic-bezier(0.075, 0.82, 0.165, 1), width .3s cubic-bezier(0.075, 0.82, 0.165, 1), height .3s cubic-bezier(0.075, 0.82, 0.165, 1);\n}\n.menu-module_menu__3tJFo svg {\n  display: inline-block;\n  vertical-align: initial;\n}\n.menu-module_menu__3tJFo.menu-module_full__2T-xJ {\n  left: 0;\n  height: 100%;\n  width: var(--editor-menu-width);\n  transform: none;\n}\n.menu-module_menurh__ryZrO {\n  height: auto;\n}\n\n.menu-module_menu__3tJFo svg {\n  margin-bottom: -3px;\n  cursor: pointer;\n}\n.menu-module_menu__3tJFo svg.menu-module_unibtn__3xwXz {\n  position: absolute;\n  right: 23px;\n  margin: 3px 7px;\n}\n\n.menu-module_menu__3tJFo svg.menu-module_eye__3r6NQ {\n  position: absolute;\n  right: 0;\n  margin: 3px 7px;\n}\n\n.menu-module_mhead__1pA2z {\n  display: flex;\n  justify-content: space-around;\n  padding: 0px 4px 4px 4px;\n}\n.menu-module_mhead__1pA2z svg {\n  width: 24px;\n  height: 24px;\n  padding: 3px;\n}\n.menu-module_hmenu__Rse6B  {\n  padding: 3px;\n  cursor: pointer;\n  position: relative;\n}\n.menu-module_menu__3tJFo ul {\n  margin: 2px 0px;\n  padding: 0px 0px 3px 0;\n}\n.menu-module_menu__3tJFo > div {\n  padding: 4px 0;\n  cursor: pointer;\n}\n.menu-module_menu__3tJFo .menu-module_sbopen__FVP6G {\n  color: #ccc;\n}\n.menu-module_menu__3tJFo li {\n  list-style: none;\n  padding: 4px 6px 4px 20px;\n  cursor: pointer;\n}\n.menu-module_open__1r8nP {\n  color: rgb(195 175 144);\n}\n.menu-module_mactive__ka-lp {\n  background-color: rgb(55,55,61);\n  color: rgb(255 193 100);\n}\n.menu-module_multiusers__3wEda {\n  padding-left: 16px;\n}\n.menu-module_multiusers__3wEda small {\n  margin-top: -4px;\n  display: inline-block;\n  position: absolute;\n  font-size: 9px;\n}\n\n.menu-module_menulist__2cpKO {\n  max-height: 100%;\n  overflow: scroll;\n  padding-bottom: 30px;\n}\n.menu-module_menub__eMuJa {\n  display: flex;\n  justify-content: space-around;\n  flex-direction: column;\n  padding: 4px;\n}\n\n.menu-module_menubaction__3JPZB {\n  background-color: rgb(0,122,204);\n  display: block;\n  font-weight: bold;\n  line-height: 30px;\n  padding: 0 6px;\n  color: #fff;\n  cursor: pointer;\n  margin: 7px;\n  text-align: center;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  text-align: center;\n}\n.menu-module_menubaction__3JPZB.menu-module_closemenubaction__1lf-n {\n  background-color: rgb(235, 38, 94);\n}\n\n.menu-module_resetmenub__2_Z5g {\n  margin-top: 40px;\n}\n.menu-module_isModif__TUfP2 {\n  font-weight: bold;\n  float: revert;\n  float: right;\n  padding: 0 2px;\n}";
var styles$2 = {"menu":"menu-module_menu__3tJFo","full":"menu-module_full__2T-xJ","menurh":"menu-module_menurh__ryZrO","unibtn":"menu-module_unibtn__3xwXz","eye":"menu-module_eye__3r6NQ","mhead":"menu-module_mhead__1pA2z","hmenu":"menu-module_hmenu__Rse6B","sbopen":"menu-module_sbopen__FVP6G","open":"menu-module_open__1r8nP","mactive":"menu-module_mactive__ka-lp","multiusers":"menu-module_multiusers__3wEda","menulist":"menu-module_menulist__2cpKO","menub":"menu-module_menub__eMuJa","menubaction":"menu-module_menubaction__3JPZB","closemenubaction":"menu-module_closemenubaction__1lf-n","resetmenub":"menu-module_resetmenub__2_Z5g","isModif":"menu-module_isModif__TUfP2"};
styleInject(css_248z$2);

var MATERIAL_TYPES_TO_SHADERS = {
  MeshDepthMaterial: 'depth',
  MeshDistanceMaterial: 'distanceRGBA',
  MeshNormalMaterial: 'normal',
  MeshBasicMaterial: 'basic',
  MeshLambertMaterial: 'lambert',
  MeshPhongMaterial: 'phong',
  MeshToonMaterial: 'toon',
  MeshStandardMaterial: 'physical',
  MeshPhysicalMaterial: 'physical',
  MeshMatcapMaterial: 'matcap',
  LineBasicMaterial: 'basic',
  LineDashedMaterial: 'dashed',
  PointsMaterial: 'points',
  ShadowMaterial: 'shadow',
  SpriteMaterial: 'sprite'
};
var getTypeForMaterial = function getTypeForMaterial(material) {
  var builtinType = MATERIAL_TYPES_TO_SHADERS[material];
  return builtinType || (material === 'ShaderMaterial' ? 'shader' : 'unknown');
};
var getNameForEditorMaterial = function getNameForEditorMaterial(material, programGl) {
  var name = '';

  if (material.isEffect) {
    name = material.name.replace('Effect', '').toLowerCase();
  } else {
    name = getTypeForMaterial(programGl.name);
  }

  name = name + '_' + programGl.id;
  return name;
};
var getShaderWithObc = function getShaderWithObc(material) {
  var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];
  var dummyShaderLib = Object.assign({}, ShaderLib[builtinType] ? ShaderLib[builtinType] : material);

  if (ShaderLib[builtinType]) {
    for (var _i = 0, _Object$entries = Object.entries(dummyShaderLib.uniforms); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          value = _Object$entries$_i[1];
      var val = value;
      val.isNativeUniforms = true;
    }
  } // TODO DEBUG UNIFORMS OF CUSTOM MATERIALS SHADER IS NOT SHOWING


  if (!dummyShaderLib.obcAdded && !material.obcAdded) {
    material.obcAdded = true;
    dummyShaderLib.obcAdded = true;
    material.onBeforeCompile.call(material, dummyShaderLib);
    dummyShaderLib.uniforms = Object.assign(dummyShaderLib.uniforms, material.uniforms);
  }

  return dummyShaderLib;
};

var LiMenu = function LiMenu(_ref) {
  var type = _ref.type,
      program = _ref.program;
  var snapshot = useProxy(editorState);
  var material = program.material;
  var programGl = program.program;
  var name = getNameForEditorMaterial(material, programGl);

  var getModif = function getModif(type) {
    if (!editorContext.monacoRef) {
      return;
    }

    var oModel = editorContext.monacoRef.editor.getModel("urn:" + name + "." + type + "_orig");
    var mModel = editorContext.monacoRef.editor.getModel("urn:" + name + "." + type);

    if (!oModel || !mModel) {
      return null;
    }

    return oModel.getValue() !== mModel.getValue();
  }; // TODO M DISPARAIT QUAND ON MINIMIZE L'EDITOR


  return /*#__PURE__*/React.createElement("li", {
    className: (snapshot.tabs["urn:" + name + "." + type] ? styles$2.open : '') + " + ' ' + " + (snapshot.activeMaterial && snapshot.activeMaterial.model === "urn:" + name + "." + type ? styles$2.mactive : ''),
    onClick: function onClick() {
      var value = {
        type: type,
        open: true,
        cachedModel: "urn:" + name + "." + type,
        isModif: false,
        model: "urn:" + name + "." + type
      };
      editorState.activeMaterial = value;
      editorContext.activeMaterialRef[value.model] = program;
      editorState.tabs["urn:" + name + "." + type] = value;
      editorState.showUniforms = true;
      editorState.showEditor = true;
      editorState.diffMode = false;
      editorState.obcMode = false;
      editorState.triggerUpdate++;
      checkIfModifications();
    }
  }, type === 'frag' ? /*#__PURE__*/React.createElement(IoImageOutline, {
    className: styles.colorf
  }) : /*#__PURE__*/React.createElement(IoCubeOutline, {
    className: styles.colorv
  }), ' ', name, ".", type, ' ', getModif(type) && /*#__PURE__*/React.createElement("span", {
    className: styles$2.isModif
  }, "M"));
};

var SubMenu = function SubMenu(_ref) {
  var program = _ref.program;
  var snapshot = useProxy(editorState);

  var _useState = useState(true),
      open = _useState[0],
      set = _useState[1];

  var material = program.material;
  var programGl = program.program;

  if (!programGl) {
    return null;
  }

  var name = getNameForEditorMaterial(material, programGl);

  var hide = function hide(e) {
    e.stopPropagation(); // TODO PP LIBS renderToScreen or pass.enabled

    material.visible = !material.visible;
    material.enabled = !material.enabled;
    material.needsUpdate = true;
    editorState.triggerUpdate++;
  };

  var showUniforms = function showUniforms(e) {
    e.stopPropagation();
    var value = {
      type: '',
      open: true,
      isModif: false,
      model: "urn:" + name
    };
    editorState.activeMaterial = value;
    editorContext.activeMaterialRef[value.model] = program;
    editorState.showEditor = false;
    editorState.diffMode = false;
    editorState.obcMode = false;
    editorState.showUniforms = true;
    editorState.triggerUpdate++;
  };

  return programGl && material ? /*#__PURE__*/React.createElement("div", {
    key: snapshot.triggerUpdate,
    className: open ? styles$2.sbopen : ''
  }, /*#__PURE__*/React.createElement("div", {
    className: styles$2.hmenu + " " + (snapshot.tabs["urn:" + name + ".frag"] || snapshot.tabs["urn:" + name + ".vert"] ? styles$2.open : ''),
    onClick: showUniforms
  }, open ? /*#__PURE__*/React.createElement(RiArrowDownSFill, {
    onClick: function onClick() {
      set(!open);
    }
  }) : /*#__PURE__*/React.createElement(RiArrowRightSFill, {
    onClick: function onClick() {
      set(!open);
    }
  }), " ", name, material && material.numberOfMaterialsUser > 1 && /*#__PURE__*/React.createElement("span", {
    className: styles$2.multiusers
  }, /*#__PURE__*/React.createElement(IoCubeOutline, null), /*#__PURE__*/React.createElement("small", null, material.numberOfMaterialsUser)), /*#__PURE__*/React.createElement(VscSettings, {
    className: styles$2.unibtn
  }), material && !material.visible && !material.isEffect ? /*#__PURE__*/React.createElement(IoEyeOffOutline, {
    onClick: hide,
    className: styles$2.eye
  }) : /*#__PURE__*/React.createElement(IoEyeOutline, {
    onClick: hide,
    className: styles$2.eye
  })), open && /*#__PURE__*/React.createElement("ul", null, material.fragmentShader && /*#__PURE__*/React.createElement(LiMenu, {
    program: program,
    type: 'frag'
  }), material.vertexShader && /*#__PURE__*/React.createElement(LiMenu, {
    program: program,
    type: 'vert'
  }))) : null;
};

var HeadMenu = function HeadMenu() {
  var snapshot = useProxy(editorState);
  return /*#__PURE__*/React.createElement("div", {
    key: snapshot.triggerUpdate,
    className: styles$2.mhead
  }, editorState.showEditor && editorState.fullScreen && /*#__PURE__*/React.createElement(BiDockRight, {
    onClick: function onClick() {
      editorState.fullScreen = false;
    }
  }), editorState.showEditor && !editorState.fullScreen && /*#__PURE__*/React.createElement(AiOutlineFullscreen, {
    onClick: function onClick() {
      editorState.fullScreen = true;
    }
  }), /*#__PURE__*/React.createElement("div", {
    onClick: function onClick() {
      editorState.showEditor = !editorState.showEditor;
      editorState.diffMode = false;
    }
  }, snapshot.showEditor ? /*#__PURE__*/React.createElement(BsArrowBarRight, null) : /*#__PURE__*/React.createElement(BsArrowBarLeft, null)));
};

var BottomAction = function BottomAction() {
  var snapshot = useProxy(editorState);
  var isShader = false;

  if (!editorContextState.monacoRef || !editorState.activeMaterial.model) {
    return null;
  }

  var activeMat = editorContextState.activeMaterialRef[editorState.activeMaterial.model];

  if (activeMat && activeMat.material) {
    isShader = activeMat.material.type === ('ShaderMaterial' );
  }

  if (editorState.obcMode && editorState.activeMaterial.cachedModel) {
    activeMat = editorContextState.activeMaterialRef[editorState.activeMaterial.cachedModel];
  }

  if (!activeMat) {
    return null;
  }

  var material = activeMat.material;

  var cancelChange = function cancelChange() {
    var type = editorState.activeMaterial.type;
    var program = activeMat.program;
    var name = getNameForEditorMaterial(material, program);
    var oModel = editorContextState.monacoRef.editor.getModel("urn:" + name + "." + type + "_orig");
    var model = editorContextState.monacoRef.editor.getModel("urn:" + name + "." + type);

    if (model) {
      model.setValue(oModel.getValue());
    }

    editorState.activeMaterial.isModif = false;
  };

  var openObcMode = function openObcMode() {
    editorState.activeMaterial.cachedModel = editorState.activeMaterial.model + '';
    setTimeout(function () {
      editorState.activeMaterial.model = 'urn:obc_result';
      editorState.showEditor = true;
      editorState.diffMode = false;
      editorState.obcMode = true;
    }, 0);
  };

  var closeObcMode = function closeObcMode() {
    editorState.activeMaterial.model = editorState.activeMaterial.cachedModel;
    editorState.activeMaterial.cachedModel = null;
    editorState.diffMode = false;
    editorState.obcMode = false;
    editorState.triggerUpdate++;
  };

  return snapshot.activeMaterial && snapshot.activeMaterial.isModif && snapshot.showEditor && material ? /*#__PURE__*/React.createElement("div", {
    key: snapshot.triggerUpdate,
    className: styles$2.menub
  }, snapshot.obcMode && /*#__PURE__*/React.createElement("div", {
    className: "" + styles$2.menubaction,
    onClick: function onClick() {
      editorContextState.editor.trigger('source', 'editor.action.clipboardCopyAction');
    }
  }, /*#__PURE__*/React.createElement(HiOutlineClipboardCopy, null), " Copy"), !snapshot.diffMode && !snapshot.obcMode && /*#__PURE__*/React.createElement("div", {
    className: styles$2.menubaction,
    onClick: function onClick() {
      editorState.diffMode = true;
    }
  }, /*#__PURE__*/React.createElement(VscCompareChanges, null), " Analyze diff"), snapshot.diffMode && !snapshot.obcMode && /*#__PURE__*/React.createElement("div", {
    className: styles$2.menubaction + " " + styles$2.closemenubaction,
    onClick: function onClick() {
      editorState.diffMode = false;
    }
  }, /*#__PURE__*/React.createElement(VscCompareChanges, null), " Close diff"), !isShader && !snapshot.diffMode && !snapshot.obcMode && material && !material.isEffect && /*#__PURE__*/React.createElement("div", {
    className: styles$2.menubaction,
    onClick: function onClick() {
      openObcMode();
    }
  }, /*#__PURE__*/React.createElement(AiOutlineFunction, null), " onBeforeCompile"), !isShader && snapshot.obcMode && material && !material.isEffect && /*#__PURE__*/React.createElement("div", {
    className: styles$2.menubaction + " " + styles$2.closemenubaction,
    onClick: function onClick() {
      closeObcMode();
    }
  }, /*#__PURE__*/React.createElement(AiOutlineFunction, null), " onBeforeCompile"), !snapshot.obcMode && !snapshot.diffMode && /*#__PURE__*/React.createElement("div", {
    className: styles$2.menubaction + " " + styles$2.closemenubaction + " " + styles$2.resetmenub,
    onClick: cancelChange
  }, /*#__PURE__*/React.createElement(BiEraser, null), " Reset shader")) : null;
};

var color = /*#__PURE__*/new Color();
var UniformsMenu = function UniformsMenu() {
  var snapshot = useProxy(editorState);

  var _React$useState = React.useState(null),
      store = _React$useState[0],
      setSelection = _React$useState[1];

  if (!editorContextState.monacoRef) {
    return null;
  }

  if (!editorContextState.activeMaterialRef || !editorState.activeMaterial.model) {
    return null;
  }

  var activeMat = editorContextState.activeMaterialRef[editorState.activeMaterial.model];

  if (!activeMat) {
    return null;
  }

  var material = activeMat.material;

  if (!editorState.showUniforms || !material.uniforms) {
    return null;
  }

  var filteredItems = {};

  if (material.uniforms.size && material.uniforms.size > 0) {
    material.uniforms.forEach(function (uniform, key) {
      if (!uniform.isNativeUniforms && key !== 'time') {
        if (typeof uniform.value === 'number') {
          uniform.min = -1;
          uniform.max = 1;
        }

        if (uniform.type) {
          delete uniform.type;
        }

        if (uniform && uniform.value && uniform.value.image) {
          filteredItems[key] = {
            image: uniform.value
          };
          uniform.copyRef = uniform.value.image.currentSrc;
        } else if (uniform.value && uniform.value.isColor) {
          var col = uniform.value;
          filteredItems[key] = {
            r: col.r * 255,
            g: col.g * 255,
            b: col.b * 255
          };
        } else {
          filteredItems[key] = uniform;
        }

        material.uniforms.set(key, uniform);
        Object.entries(filteredItems[key]).map(function (_ref) {
          var skey = _ref[0],
              value = _ref[1];

          if (typeof value === 'string') {
            delete filteredItems[key][skey];
          }
        });
      }
    });
  } else if (typeof material.uniforms === 'object') {
    if (Object.keys(material.uniforms).length === 0) {
      return null;
    }

    Object.entries(material.uniforms).map(function (_ref2) {
      var key = _ref2[0],
          uniform = _ref2[1];

      if (!uniform.isNativeUniforms && key !== 'time') {
        if (typeof uniform.value === 'number') {
          uniform.min = Math.min(-1, -Math.round(uniform.value));
          uniform.max = Math.max(1, Math.round(uniform.value));
        }

        if (uniform.type) {
          delete uniform.type;
        }

        if (uniform && uniform.value && uniform.value.image) {
          filteredItems[key] = {
            image: uniform.value
          };
          uniform.copyRef = uniform.value.image.currentSrc;
        } else if (uniform.value && uniform.value.isColor) {
          var col = uniform.value;
          filteredItems[key] = {
            r: col.r * 255,
            g: col.g * 255,
            b: col.b * 255
          };
        } else {
          filteredItems[key] = uniform;
        }

        Object.entries(filteredItems[key]).map(function (_ref3) {
          var skey = _ref3[0],
              value = _ref3[1];

          if (typeof value === 'string') {
            delete filteredItems[key][skey];
          }
        });
      }
    });
  }

  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Leva, {
    fill: true,
    flat: true,
    hideTitleBar: true,
    oneLineLabels: false
  }), /*#__PURE__*/React.createElement(LevaPanel, {
    fill: true,
    flat: true,
    hideTitleBar: true,
    store: store,
    oneLineLabels: false
  }), /*#__PURE__*/React.createElement("div", {
    key: snapshot.triggerUpdate
  }, /*#__PURE__*/React.createElement(UniformComp, {
    filteredItems: filteredItems,
    setSelection: setSelection,
    uniforms: material.uniforms,
    store: store
  })));
};

var loadTexture = function loadTexture(uniforms, materialUniform, key, value) {
  if (materialUniform && materialUniform.value && materialUniform.value.image) {
    if (value && value !== materialUniform.value.image.preventDouble) {
      new TextureLoader().load(value, function (x) {
        materialUniform.value = x;
        materialUniform.value.wrapS = materialUniform.value.wrapT = RepeatWrapping;
        materialUniform.value.image.preventDouble = value;
        materialUniform.value.image.isOriginal = false;
        materialUniform.value.needsUpdate = true;
        setUniformValue(uniforms, materialUniform, key);
      });
    } else if (!value && !materialUniform.value.image.isOriginal) {
      new TextureLoader().load(materialUniform.copyRef, function (x) {
        materialUniform.value = x;
        materialUniform.value.wrapS = materialUniform.value.wrapT = RepeatWrapping;
        materialUniform.value.image.preventDouble = value;
        materialUniform.value.image.isOriginal = true;
        materialUniform.value.needsUpdate = true;
        setUniformValue(uniforms, materialUniform, key);
      });
    }
  }
};

var UniformComp = function UniformComp(_ref4) {
  var filteredItems = _ref4.filteredItems,
      uniforms = _ref4.uniforms,
      setSelection = _ref4.setSelection;
  var store = useCreateStore();

  var _useControls = useControls(function () {
    return filteredItems;
  }, {
    store: store
  }),
      elements = _useControls[0];

  useEffect(function () {
    for (var _i = 0, _Object$entries = Object.entries(elements); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];
      var val = value;
      var materialUniform = uniforms[key] || uniforms.get(key); // is image

      if (typeof value === 'string' || !value) {
        loadTexture(uniforms, materialUniform, key, value);
      } else {
        if (materialUniform) {
          if (val['r'] && val['g'] && val['b']) {
            var factor = 255;
            materialUniform.value = color.setRGB(val['r'] / factor, val['g'] / factor, val['b'] / factor);
            setUniformValue(uniforms, materialUniform, key);
          } else {
            materialUniform.value = value;
            setUniformValue(uniforms, materialUniform, key);
          }
        }
      }
    }
  }, [elements]);
  useEffect(function () {
    setSelection(store);
  }, [store, setSelection]);
  return null;
};

var setUniformValue = function setUniformValue(uniforms, materialUniform, key) {
  if (!uniforms[key]) {
    uniforms.set(key, materialUniform);
  }
};

var Menu = function Menu() {
  var snapshot = useProxy(editorState);
  var editorWidth = editorContext.editorWidth;
  var editorHeight = editorContext.editorMinusHeight;
  var menuSize = 160;
  var bind = useDrag(function (_ref) {
    var down = _ref.down,
        _ref$delta = _ref.delta,
        mx = _ref$delta[0],
        my = _ref$delta[1];

    if (editorState.fullScreen) {
      return;
    }

    if (down && typeof window !== 'undefined') {
      editorWidth -= editorWidth - mx > window.innerWidth - menuSize ? 0 : mx;
      editorHeight -= editorHeight - my < 0 ? 0 : my;
      editorContext.dom.current.style.setProperty('--editor-width', editorWidth + 'px');
      editorContext.dom.current.style.setProperty('--editor-minus-height', editorHeight + 'px');
    } else {
      if (typeof window !== 'undefined') {
        if (window.innerWidth - editorWidth < 200) {
          editorWidth = window.innerWidth - menuSize;
        }

        if (editorHeight < 40) {
          editorHeight = 0;
        }

        editorContext.dom.current.style.setProperty('--editor-width', editorWidth + 'px');
        editorContext.dom.current.style.setProperty('--editor-minus-height', editorHeight + 'px');
      }

      editorContext.editorWidth = editorWidth;
      editorContext.editorMinusHeight = editorHeight;
    }
  });
  return editorContext.programs.length > 0 ? /*#__PURE__*/React.createElement("div", Object.assign({
    className: styles$2.menu + " " + (!snapshot.showEditor ? styles$2.menurh : '') + " " + (snapshot.showEditor && snapshot.fullScreen ? styles$2.full : '')
  }, bind(), {
    style: {
      touchAction: 'none'
    }
  }), /*#__PURE__*/React.createElement(HeadMenu, null), /*#__PURE__*/React.createElement("div", {
    key: snapshot.triggerUpdate,
    className: styles$2.menulist
  }, editorContext.programs.map(function (value, key) {
    return /*#__PURE__*/React.createElement(SubMenu, {
      program: value,
      key: key.toString()
    });
  })), /*#__PURE__*/React.createElement(UniformsMenu, null), /*#__PURE__*/React.createElement(BottomAction, null)) : null;
};

var FullScreen = function FullScreen() {
  var snapshot = useProxy(editorState);
  var embed = useRef(null);
  var div = document.createElement('div');
  div.style.position = 'absolute';
  div.style.left = '0';
  div.style.right = '0';
  div.style.bottom = '0';
  div.style.top = '0';

  var _useState = useState(function () {
    return div;
  }),
      el = _useState[0];

  var element = editorContextState.gl.domElement;
  useEffect(function () {
    if (el && embed.current) {
      document.body.appendChild(el);
      el.appendChild(element);
      embed.current.appendChild(editorContextState.gl.domElement);
      return function () {// if (el) document.body.removeChild(el);
        // unmountComponentAtNode(el);
      };
    }

    return undefined;
  }, [el, element]); // use drag https://codesandbox.io/s/rkgzi?file=/src/index.js

  return /*#__PURE__*/createPortal( /*#__PURE__*/React.createElement("div", {
    ref: embed,
    className: styles.embed + " " + (!snapshot.diffMode && snapshot.fullScreen && snapshot.showEditor ? styles.embedfull : '')
  }, /*#__PURE__*/React.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "54",
    height: "14",
    viewBox: "0 0 54 14"
  }, /*#__PURE__*/React.createElement("g", {
    fill: "none",
    fillRule: "evenodd",
    transform: "translate(1 1)"
  }, /*#__PURE__*/React.createElement("circle", {
    cx: "6",
    cy: "6",
    r: "6",
    fill: "#FF5F56",
    stroke: "#E0443E",
    strokeWidth: ".5"
  }), /*#__PURE__*/React.createElement("circle", {
    cx: "26",
    cy: "6",
    r: "6",
    fill: "#FFBD2E",
    stroke: "#DEA123",
    strokeWidth: ".5"
  }), /*#__PURE__*/React.createElement("circle", {
    cx: "46",
    cy: "6",
    r: "6",
    fill: "#27C93F",
    stroke: "#1AAB29",
    strokeWidth: ".5"
  }))), /*#__PURE__*/React.createElement("div", {
    className: styles.embedglass
  })), el);
};

var base = "vs-dark";
var inherit = true;
var rules = [
	{
		background: "272822",
		token: ""
	},
	{
		foreground: "75715e",
		token: "comment"
	},
	{
		foreground: "e6db74",
		token: "string"
	},
	{
		foreground: "ae81ff",
		token: "constant.numeric"
	},
	{
		foreground: "ae81ff",
		token: "constant.language"
	},
	{
		foreground: "ae81ff",
		token: "constant.character"
	},
	{
		foreground: "ae81ff",
		token: "constant.other"
	},
	{
		foreground: "f92672",
		token: "keyword"
	},
	{
		foreground: "f92672",
		token: "storage"
	},
	{
		foreground: "66d9ef",
		fontStyle: "italic",
		token: "storage.type"
	},
	{
		foreground: "a6e22e",
		fontStyle: "underline",
		token: "entity.name.class"
	},
	{
		foreground: "a6e22e",
		fontStyle: "italic underline",
		token: "entity.other.inherited-class"
	},
	{
		foreground: "a6e22e",
		token: "entity.name.function"
	},
	{
		foreground: "fd971f",
		fontStyle: "italic",
		token: "variable.parameter"
	},
	{
		foreground: "f92672",
		token: "entity.name.tag"
	},
	{
		foreground: "a6e22e",
		token: "entity.other.attribute-name"
	},
	{
		foreground: "66d9ef",
		token: "support.function"
	},
	{
		foreground: "66d9ef",
		token: "support.constant"
	},
	{
		foreground: "66d9ef",
		fontStyle: "italic",
		token: "support.type"
	},
	{
		foreground: "66d9ef",
		fontStyle: "italic",
		token: "support.class"
	},
	{
		foreground: "f8f8f0",
		background: "f92672",
		token: "invalid"
	},
	{
		foreground: "f8f8f0",
		background: "ae81ff",
		token: "invalid.deprecated"
	},
	{
		foreground: "cfcfc2",
		token: "meta.structure.dictionary.json string.quoted.double.json"
	},
	{
		foreground: "75715e",
		token: "meta.diff"
	},
	{
		foreground: "75715e",
		token: "meta.diff.header"
	},
	{
		foreground: "f92672",
		token: "markup.deleted"
	},
	{
		foreground: "a6e22e",
		token: "markup.inserted"
	},
	{
		foreground: "e6db74",
		token: "markup.changed"
	},
	{
		foreground: "ae81ffa0",
		token: "constant.numeric.line-number.find-in-files - match"
	},
	{
		foreground: "e6db74",
		token: "entity.name.filename.find-in-files"
	}
];
var colors = {
	"editor.foreground": "#F8F8F2",
	"editor.background": "#272822",
	"editor.selectionBackground": "#49483E",
	"editor.lineHighlightBackground": "#3E3D32",
	"editorCursor.foreground": "#F8F8F0",
	"editorWhitespace.foreground": "#3B3A32",
	"editorIndentGuide.activeBackground": "#9D550FB0",
	"editor.selectionHighlightBorder": "#222218"
};
var Monokai = {
	base: base,
	inherit: inherit,
	rules: rules,
	colors: colors
};

var checkIfModifications = function checkIfModifications() {
  var oModel = editorContext.monacoRef.editor.getModel(editorState.activeMaterial.model + '_orig');
  var mModel = editorContext.monacoRef.editor.getModel(editorState.activeMaterial.model);

  if (oModel && mModel) {
    var origin = oModel.getValue();
    var modif = mModel.getValue();
  }

  editorState.activeMaterial.isModif = origin !== modif;
};
var updateActiveShader = function updateActiveShader(value, type) {
  if (!editorState.activeMaterial.model) {
    return;
  }

  var activeMat = editorContext.activeMaterialRef[editorState.activeMaterial.model];
  var material = activeMat.material;
  editorContext.monacoRef.editor.setModelMarkers(editorContext.editor.getModel(), editorState.activeMaterial.model, value);

  if (material) {
    if (material.isEffect) {
      material.vertexShader = type === 'vert' ? value : material.vertexShader;
      material.fragmentShader = type === 'frag' ? value : material.fragmentShader;
      activeMat.effect.recompile(editorContext.gl);
    } else {
      material.editorOnBeforeCompile = function (shader) {
        shader.vertexShader = type === 'vert' ? value : material.vertexShader;
        shader.fragmentShader = type === 'frag' ? value : material.fragmentShader;
      };
    }

    checkIfModifications(); // if (type === 'vert') {
    //   material.setOption({
    //     vertexMainOutro: value
    //   })
    // } else if (type === 'frag') {
    //   material.setOption({
    //     fragmentColorTransform: value
    //   })

    material.needsUpdate = true;
    editorState.triggerUpdate++;

    material.customProgramCacheKey = function () {
      return editorState.triggerUpdate;
    };
  }
};
var MaterialEditor = function MaterialEditor() {
  var _useState = useState(false),
      instanceReady = _useState[0],
      setinstanceReady = _useState[1];

  useLayoutEffect(function () {
    if (typeof window !== "undefined" && !editorContext.monacoRef) {
      loader.init().then(function (monacoInstance) {
        editorContext.monacoRef = monacoInstance;
        editorContext.monacoRef.editor.defineTheme('monokai', Monokai);
        setinstanceReady(true);
        monacoInstance.languages.register({
          id: 'cshader'
        });
        monacoInstance.languages.setLanguageConfiguration('cshader', conf);
        monacoInstance.languages.setMonarchTokensProvider('cshader', language);
      })["catch"](function (error) {
        return console.error('An error occurred during initialization of Monaco: ', error);
      });
    }
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, instanceReady && /*#__PURE__*/React.createElement(EditorDom, null));
};

var handleEditorValidation = function handleEditorValidation() {
  var diagnostics = editorState.diagnostics;

  if (!editorState.activeMaterial.model) {
    return;
  }

  var material = editorContext.activeMaterialRef[editorState.activeMaterial.model].material;

  if (diagnostics && diagnostics.fragmentShader && !diagnostics.runnable && editorContext.monacoRef) {
    var error = diagnostics.fragmentShader.log === '' ? diagnostics.vertexShader : diagnostics.fragmentShader;
    var errs = error.log.split('\n'); // to count the margin

    var prefix = error.prefix.split('\n');
    errs.pop();
    var errorfromEffectAdjust = 0;
    var markets = errs.map(function (err) {
      if (material && material.isEffect && editorContext.editor) {
        var type = editorState.activeMaterial.type;
        var getVoidEffectLine = type === 'frag' ? "e" + material.id + "MainImage" : "e" + material.id + "MainUv";
        var fullProg = type === 'frag' ? diagnostics.frag : diagnostics.vert;
        var progArr = fullProg.split('\n');
        errorfromEffectAdjust = progArr.findIndex(function (el) {
          return el.includes(getVoidEffectLine);
        });
        var model = editorContext.editor.getModel();

        if (model) {
          var editorTxtArr = model.getValue().split('\n');
          var getVoidEditorLine = type === 'frag' ? "mainImage" : "mainUv";
          var adjustUniforms = editorTxtArr.findIndex(function (el) {
            return el.includes(getVoidEditorLine);
          });
          errorfromEffectAdjust -= adjustUniforms;
        }
      }

      var re = new RegExp('[^0-9]+ ([0-9]+):([0-9]+):');
      var rl = err.match(re) || [];
      var message = err.split(':');
      message[2] = (parseInt(message[2]) - (material.isEffect ? errorfromEffectAdjust : prefix.length) || '').toString();
      var pos = parseInt(rl[1] || 1);
      var lin = parseInt(rl[2] || 1) - (material.isEffect ? errorfromEffectAdjust : prefix.length);
      return {
        startLineNumber: lin,
        startColumn: pos,
        endLineNumber: lin,
        endColumn: 1000,
        message: message.join(':'),
        severity: editorContext.monacoRef.MarkerSeverity.Error
      };
    });
    editorContext.monacoRef.editor.setModelMarkers(editorContext.editor.getModel(), editorState.activeMaterial.model, markets);
  }
};

var HandleError = function HandleError() {
  var snapshot = useProxy(editorState);
  useEffect(function () {
    // const diagnostics: any = snapshot.diagnostics
    // if (diagnostics && diagnostics.fragmentShader && !diagnostics.runnable) {
    handleEditorValidation(); // }
  }, [snapshot.diagnostics]);
  return null;
};

var EditorDom = function EditorDom() {
  var dom = useRef(null);
  var snapshot = useProxy(editorState);
  editorContext.dom = dom;
  return /*#__PURE__*/React.createElement("div", {
    ref: dom,
    className: styles.editor_c + " " + (snapshot.showEditor ? '' : styles.editor_h) + " " + (snapshot.showEditor && snapshot.fullScreen ? styles.full : '') + " " + editorState.className
  }, /*#__PURE__*/React.createElement(Menu, null), editorContextState.gl && /*#__PURE__*/React.createElement(FullScreen, null), snapshot.showEditor && /*#__PURE__*/React.createElement(EditorText, null));
};

var EditorEdit = function EditorEdit() {
  var snapshot = useProxy(editorState);

  var _useState2 = useState(false),
      isEditorReady = _useState2[0],
      setIsEditorReady = _useState2[1];

  function handleEditorDidMount(editor, _) {
    editorContext.editor = editor;
    setIsEditorReady(true);
  }

  useEffect(function () {
    // at initialization of any new active material set the 2 models
    if (editorState.activeMaterial && editorContext.activeMaterialRef && editorContext.monacoRef && editorState.activeMaterial.model) {
      var type = editorState.activeMaterial.type;
      var activeMat = editorContext.activeMaterialRef[editorState.activeMaterial.model];

      if (!activeMat) {
        return;
      }

      var material = activeMat.material;
      var program = activeMat.program;

      if (isEditorReady && material) {
        var name = getNameForEditorMaterial(material, program);
        var textContent;

        if (type === 'frag') {
          textContent = replaceShaderChunks(material.fragmentShader);
        } else {
          textContent = replaceShaderChunks(material.vertexShader);
        }

        if (!editorContext.monacoRef.editor.getModel("urn:" + name + "." + type + "_orig")) {
          editorContext.monacoRef.editor.createModel(textContent, 'cshader', "urn:" + name + "." + type + "_orig"); // TODO ADD OPTION

          if (material.type !== 'ShaderMaterial' && material.type !== 'RawShaderMaterial' && !material.isEffect) {
            editorContext.editor.trigger('fold', 'editor.foldLevel1');
          }
        }
      }
    }
  }, [isEditorReady, snapshot.activeMaterial, editorContext.monacoRef]);

  var getText = function getText() {
    if (!editorState.activeMaterial.model) {
      return '';
    }

    var textContent;
    var type = editorState.activeMaterial.type;
    var model = editorState.activeMaterial.model;
    var activeMat = editorContext.activeMaterialRef[editorState.activeMaterial.model];

    if (activeMat) {
      var program = activeMat.program;
      var material = activeMat.material;

      if (type === 'frag') {
        textContent = replaceShaderChunks(material ? material.fragmentShader : program.fragmentShader);
      } else if (type === 'vert') {
        textContent = replaceShaderChunks(material ? material.vertexShader : program.vertexShader);
      }
    }

    if (model === 'urn:obc_result' && editorState.obcMode) {
      var result = generateOBc();

      if (editorContext.monacoRef.editor.getModel('urn:obc_result')) {
        editorContext.monacoRef.editor.getModel('urn:obc_result').setValue(result);
      }

      return result;
    }

    return textContent;
  };

  return /*#__PURE__*/React.createElement(Editor, {
    className: styles.editor,
    language: "cshader",
    theme: 'vs-dark',
    onMount: handleEditorDidMount,
    height: '100%',
    keepCurrentModel: true,
    path: snapshot.activeMaterial.model + '',
    defaultLanguage: snapshot.activeMaterial.model === 'urn:obc_result' ? 'javascript' : 'cshader',
    defaultValue: getText(),
    onChange: function onChange(frag) {
      if (editorState.obcMode) {
        return false;
      }

      updateActiveShader(frag, snapshot.activeMaterial.type);
      return false;
    },
    // onValidate={handleEditorValidation}
    options: {
      formatOnType: true,
      foldingHighlight: false,
      folding: true,
      foldingStrategy: 'auto'
    }
  });
};

var GetDiff = function GetDiff() {
  var model = editorState.activeMaterial.model;

  var _useState3 = useState(false),
      isEditorReady = _useState3[0],
      setIsEditorReady = _useState3[1];

  function handleEditorDidMount(editor, _) {
    editorContext.diffEditor = editor;
    setIsEditorReady(true);
  }

  var originalModel = editorContext.monacoRef.editor.getModel(model + '_orig');
  var modifiedModel = editorContext.monacoRef.editor.getModel(model);
  useEffect(function () {
    if (isEditorReady) {
      if (!editorContext.monacoRef.editor.getModel('diff_1')) {
        editorContext.monacoRef.editor.createModel(originalModel.getValue(), 'cshader', "diff_1");
      }

      if (!editorContext.monacoRef.editor.getModel('diff_2')) {
        editorContext.monacoRef.editor.createModel(modifiedModel.getValue(), 'cshader', "diff_2");
      }

      editorContext.diffEditor.setModel({
        original: editorContext.monacoRef.editor.getModel('diff_1'),
        modified: editorContext.monacoRef.editor.getModel('diff_2')
      });
    }

    return function () {
      if (editorContext.editor.getModel() && editorContext.diffEditor.getModel().modified.getValue()) {
        // send the update in the diff to the basic text editor
        editorContext.monacoRef.editor.getModel(editorState.activeMaterial.model).setValue(editorContext.diffEditor.getModel().modified.getValue());
      }

      var navi = editorContext.monacoRef.editor.createDiffNavigator(editorContext.diffEditor, {
        followsCaret: true,
        ignoreCharChanges: true // jump from line to line

      });
      navi.next();
    };
  }, [isEditorReady, modifiedModel, originalModel]);
  return /*#__PURE__*/React.createElement(DiffEditor, {
    className: styles.editor,
    onMount: handleEditorDidMount,
    theme: 'vs-dark',
    height: '100%',
    options: {
      formatOnType: true
    }
  });
};

var EditorText = function EditorText() {
  var snapshot = useProxy(editorState); // implement multi-tab for vertex and frag using createModel

  return snapshot.showEditor ? /*#__PURE__*/React.createElement(React.Fragment, null, snapshot.activeMaterial.type && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(HandleError, null), /*#__PURE__*/React.createElement(EditorTabs, null)), Object.keys(snapshot.tabs).length > 0 && /*#__PURE__*/React.createElement(EditorEdit, null), snapshot.showEditor && snapshot.diffMode && snapshot.activeMaterial.type && /*#__PURE__*/React.createElement(GetDiff, null)) : null;
};

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var addShaderDebugMaterial = function addShaderDebugMaterial(material) {
  var newMaterial = material;
  var shader = getShaderWithObc(newMaterial);
  newMaterial = Object.assign(newMaterial, shader);
  var epoch = Date.now();
  var canvas = editorContextState.gl.domElement;
  var res = new Vector2(canvas.clientWidth, canvas.clientHeight); // add a uniform time helper for animations
  // if (!newMaterial.uniforms.time) {
  //   newMaterial.uniforms.time = {
  //     value: 0.0
  //   }
  // }
  // wait the first compilation that will inject data into the material shaders

  setTimeout(function () {
    newMaterial.onBeforeCompile = function (shader) {
      // troika break if we attribute uniforms
      // sometimes we lose the uniforms ?
      // if (!newMaterial.editorAttributeUniforms) {
      //   newMaterial.editorAttributeUniforms = true
      if (!newMaterial.postprocess) {
        shader.uniforms = Object.assign(shader.uniforms, newMaterial.uniforms);
      } // }
      // @ts-ignore


      if (this.editorOnBeforeCompile) {
        // @ts-ignore
        this.editorOnBeforeCompile.call(this, shader);
      } // } else {
      // override with the editor
      //   shader.vertexShader = shader.vertexShader;
      //   shader.fragmentShader = shader.fragmentShader;
      // }
      // if time detected in obc or material, automatically update the value


      if (shader.uniforms.time && !newMaterial.postprocess) {
        shader.uniforms.time = {
          writable: true,
          configurable: true,

          // @ts-ignore
          get value() {
            return (Date.now() - epoch) / 1000;
          }

        };
      } // helper for resolution


      if (shader.uniforms.resolution) {
        shader.uniforms.resolution = {
          writable: true,
          configurable: true,

          // @ts-ignore
          get value() {
            return res;
          }

        };
      }
    };
  }, 0);
  return {
    debug: null,
    material: newMaterial
  };
};

var getMUIIndex = function getMUIIndex(muid) {
  return muid === 'muidEditor';
};

var isAlreadyDerived = {};
var nativePPisAlreadyDerived = [];

var _insertMaterialToEditor = function _insertMaterialToEditor(element, container, isEffect) {
  var el = isEffect ? element.screen : element;

  if (!el.material.defines) {
    el.material.defines = {};
  }

  if (!el.material.defines.muidEditor) {
    el.material.defines = Object.assign(el.material.defines || {}, {
      muidEditor: el.material.id
    });
  }

  var muid = el.material.id; // prevent to derive loop

  if (muid && !container[muid] && el.material.defines) {
    var _addShaderDebugMateri = addShaderDebugMaterial(el.material),
        material = _addShaderDebugMateri.material;

    el.material = material; // to check if multiple material users

    el.tmeDerived = true;
    el.material.numberOfMaterialsUser = 1;
    container[muid] = el.material;
    container[muid].mesh = el; // handle postprocess and react-postprocess libs

    if (element.effects) {
      var id = 0;

      for (var _iterator = _createForOfIteratorHelperLoose(element.effects), _step; !(_step = _iterator()).done;) {
        var effect = _step.value;
        effect.id = id++;
        effect.isEffect = true;
      }

      el.material.postprocess = element;
      element.recompile();
    }
  }
};

var _insertNativePostProcessToEditor = function _insertNativePostProcessToEditor(el, container) {
  var muid = el.material.id; // prevent to derive loop

  if (muid && !container[muid]) {
    var _addShaderDebugMateri2 = addShaderDebugMaterial(el.material),
        material = _addShaderDebugMateri2.material;

    el.material = material; // to check if multiple material users

    el.tmeDerived = true;
    el.material.postprocess = true;
    container[muid] = el.material;
    container[muid].mesh = el;
  }
};

var meshDebugger = /*#__PURE__*/new Mesh(undefined, /*#__PURE__*/new MeshBasicMaterial({
  color: /*#__PURE__*/new Color(0xff0000),
  side: FrontSide,
  wireframe: true,
  visible: false
}));
meshDebugger.debugMaterial = true;
var traverseMaterialsToProgram = function traverseMaterialsToProgram(scene, gl) {
  var _gl$info$programs;

  editorContextState.gl = gl;

  if (editorContextState.composer) {
    editorContextState.composer.passes.forEach(function (pass) {
      // check if is basic three shaderpass
      if (pass.fsQuad) {
        _insertNativePostProcessToEditor(pass, nativePPisAlreadyDerived);
      } // handle postprocess and react-postprocess libs


      if (pass.screen) {
        _insertMaterialToEditor(pass, isAlreadyDerived, true);
      }
    });
  }

  var programs = []; // update

  scene == null ? void 0 : scene.traverse(function (el) {
    // Vanilla return Object3D so (el instanceof Mesh || el instanceof InstancedMesh) doesn't work ?
    if (el.material) {
      if (el.debugMaterial) {
        return;
      }

      _insertMaterialToEditor(el, isAlreadyDerived); // inc counter if the mesh also use the material


      if (el.material.defines && !el.tmeDerived) {
        el.tmeDerived = true;
        el.material.numberOfMaterialsUser++;
      }
    }
  });
  (_gl$info$programs = gl.info.programs) == null ? void 0 : _gl$info$programs.forEach(function (program) {
    var cacheKeySplited = program.cacheKey.split(','); // convert and supply all mesh associated to this material to a debugger material

    var muidDerived = cacheKeySplited[cacheKeySplited.findIndex(getMUIIndex) + 1];

    if (!isNaN(muidDerived) && isAlreadyDerived[muidDerived]) {
      isAlreadyDerived[muidDerived].program = program;

      if (isAlreadyDerived[muidDerived].postprocess) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(isAlreadyDerived[muidDerived].postprocess.effects), _step2; !(_step2 = _iterator2()).done;) {
          var effect = _step2.value;
          programs.push({
            material: effect,
            program: program,
            effect: isAlreadyDerived[muidDerived].postprocess
          });
        }
      } else {
        programs.push({
          material: isAlreadyDerived[muidDerived],
          program: program
        });
      }

      if (program) {
        var programDiagnostic = program;

        if (programDiagnostic.diagnostics) {
          // if (isAlreadyDerived[muidDerived] && isAlreadyDerived[muidDerived].mesh) {
          //   if (!meshDebugger.material.visible) {
          //     meshDebugger.geometry = isAlreadyDerived[muidDerived].mesh.geometry
          //     meshDebugger.material.visible = true
          //   }
          //   meshDebugger.position.copy( isAlreadyDerived[muidDerived].mesh.position );
          //   meshDebugger.quaternion.copy( isAlreadyDerived[muidDerived].mesh.quaternion );
          //   meshDebugger.updateMatrix()
          // }
          editorState.diagnostics = programDiagnostic.diagnostics;

          if (editorState.diagnostics) {
            var frag = gl.getContext().getShaderSource(programDiagnostic.fragmentShader);
            var vert = gl.getContext().getShaderSource(programDiagnostic.fragmentShader);
            editorState.diagnostics.frag = frag;
            editorState.diagnostics.vert = vert;
          }
        }
      }
    } else {
      var result = nativePPisAlreadyDerived.filter(function (e) {
        return e.fragmentShader.includes(cacheKeySplited[0]);
      });

      if (result.length > 0) {
        result.forEach(function (pickedMaterial) {
          programs.push({
            material: pickedMaterial,
            program: program
          });
        });
      }
    }
  });

  if (programs.length !== editorContextState.programs.length) {
    editorContextState.programs = programs;
    editorState.triggerUpdate++;
  }
};

/**
 * Core components
 */

var EditorDom$1 = function EditorDom() {
  return null;
};
var editorState$1 = {};
var editorContext = {};
var materialsToProgram = {};

if (process.env.NODE_ENV === 'production' && process.env.TME_PROD !== 'SHOW') ; else {
  EditorDom$1 = function EditorDom() {
    return /*#__PURE__*/React.createElement(MaterialEditor, null);
  };

  editorState$1 = editorState;
  editorContext = editorContextState;
  materialsToProgram = traverseMaterialsToProgram;
}

export { EditorDom$1 as EditorDom, editorContext, editorState$1 as editorState, materialsToProgram };
//# sourceMappingURL=core.esm.js.map
