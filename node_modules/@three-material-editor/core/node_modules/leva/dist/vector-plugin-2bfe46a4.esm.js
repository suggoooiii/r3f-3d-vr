import React, { createContext, useContext, useCallback, useState, useRef, useEffect } from 'react';
import { Root } from '@radix-ui/react-portal';
import { dequal } from 'dequal/lite';
import shallow from 'zustand/shallow';
import { createCss } from '@stitches/react';
import { useDrag as useDrag$1 } from 'react-use-gesture';
import { Arrow, Root as Root$1, Trigger, Content } from '@radix-ui/react-tooltip';
import { writeText } from 'clipboard-polyfill/text';
import v8n from 'v8n';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

let LevaErrors;

(function (LevaErrors) {
  LevaErrors[LevaErrors["UNSUPPORTED_INPUT"] = 0] = "UNSUPPORTED_INPUT";
  LevaErrors[LevaErrors["NO_COMPONENT_FOR_TYPE"] = 1] = "NO_COMPONENT_FOR_TYPE";
  LevaErrors[LevaErrors["UNKNOWN_INPUT"] = 2] = "UNKNOWN_INPUT";
  LevaErrors[LevaErrors["DUPLICATE_KEYS"] = 3] = "DUPLICATE_KEYS";
  LevaErrors[LevaErrors["ALREADY_REGISTERED_TYPE"] = 4] = "ALREADY_REGISTERED_TYPE";
  LevaErrors[LevaErrors["CLIPBOARD_ERROR"] = 5] = "CLIPBOARD_ERROR";
  LevaErrors[LevaErrors["THEME_ERROR"] = 6] = "THEME_ERROR";
  LevaErrors[LevaErrors["PATH_DOESNT_EXIST"] = 7] = "PATH_DOESNT_EXIST";
  LevaErrors[LevaErrors["INPUT_TYPE_OVERRIDE"] = 8] = "INPUT_TYPE_OVERRIDE";
})(LevaErrors || (LevaErrors = {}));

const ErrorList = {
  [LevaErrors.UNSUPPORTED_INPUT]: (type, path) => [`An input with type \`${type}\` input was found at path \`${path}\` but it's not supported yet.`],
  [LevaErrors.NO_COMPONENT_FOR_TYPE]: (type, path) => [`Type \`${type}\` found at path \`${path}\` can't be displayed in panel because no component supports it yet.`],
  [LevaErrors.UNKNOWN_INPUT]: (path, value) => [`input at path \`${path}\` is not recognized.`, value],
  [LevaErrors.DUPLICATE_KEYS]: (key, path, prevPath) => [`Key \`${key}\` of path \`${path}\` already exists at path \`${prevPath}\`. Even nested keys need to be unique. Rename one of the keys.`],
  [LevaErrors.ALREADY_REGISTERED_TYPE]: type => [`Type ${type} has already been registered. You can't register a component with the same type.`],
  [LevaErrors.CLIPBOARD_ERROR]: value => [`Error copying the value`, value],
  [LevaErrors.THEME_ERROR]: (category, key) => [`Error accessing the theme \`${category}.${key}\` value.`],
  [LevaErrors.PATH_DOESNT_EXIST]: path => [`Error getting the value at path \`${path}\`. There is probably an error in your \`render\` function.`],
  [LevaErrors.PATH_DOESNT_EXIST]: path => [`Error accessing the value at path \`${path}\``],
  [LevaErrors.INPUT_TYPE_OVERRIDE]: type => [`Type cannot be overwritten on update (\`${type}\`)`]
};

function _log(fn, errorType, ...args) {
  const [message, ...rest] = ErrorList[errorType](...args);
  console[fn]('LEVA: ' + message, ...rest);
}

const warn = _log.bind(null, 'warn');
const log = _log.bind(null, 'log');

const Schemas = [];
const Plugins = {};
function getValueType(_ref) {
  let {
    value
  } = _ref,
      settings = _objectWithoutProperties(_ref, ["value"]);

  for (let checker of Schemas) {
    const type = checker(value, settings);
    if (type) return type;
  }

  return undefined;
}
function register(type, _ref2) {
  let {
    schema
  } = _ref2,
      plugin = _objectWithoutProperties(_ref2, ["schema"]);

  if (type in Plugins) {
    warn(LevaErrors.ALREADY_REGISTERED_TYPE, type);
    return;
  }

  Schemas.push((value, settings) => schema(value, settings) && type);
  Plugins[type] = plugin;
}

const getUniqueType = () => '__CUSTOM__PLUGIN__' + Math.random().toString(36).substr(2, 9);

function createInternalPlugin(plugin) {
  return plugin;
}
function createPlugin(plugin) {
  const type = getUniqueType();
  Plugins[type] = plugin;
  return input => _objectSpread2({
    type
  }, input);
}
function normalize$1(type, input) {
  const {
    normalize: _normalize
  } = Plugins[type];
  if (_normalize) return _normalize(input);
  return input;
}
function sanitize$1(type, value, settings, prevValue) {
  const {
    sanitize
  } = Plugins[type];
  if (sanitize) return sanitize(value, settings, prevValue);
  return value;
}
function format$1(type, value, settings) {
  const {
    format
  } = Plugins[type];
  if (format) return format(value, settings);
  return value;
}

const clamp = (x, min, max) => x > max ? max : x < min ? min : x;
const pad = (x, pad) => String(x).padStart(pad, '0');
const ceil = v => Math.sign(v) * Math.ceil(Math.abs(v));
const parseNumber = v => {
  if (typeof v === 'number') return v;

  try {
    const _v = evaluate(v);

    if (!isNaN(_v)) return _v;
  } catch (_unused) {}

  return parseFloat(v);
};
const log10 = Math.log(10);
function getStep(number) {
  let n = Math.abs(+String(number).replace('.', ''));
  if (n === 0) return 0.01;

  while (n !== 0 && n % 10 === 0) n /= 10;

  const significantDigits = Math.floor(Math.log(n) / log10) + 1;
  const numberLog = Math.floor(Math.log10(Math.abs(number)));
  const step = Math.pow(10, numberLog - significantDigits);
  return Math.max(step, 0.001);
}
const range = (v, min, max) => (v - min) / (max - min);
const invertedRange = (p, min, max) => p * (max - min) + min;
const parens = /\(([0-9+\-*/^ .]+)\)/;
const exp = /(\d+(?:\.\d+)?) ?\^ ?(\d+(?:\.\d+)?)/;
const mul = /(\d+(?:\.\d+)?) ?\* ?(\d+(?:\.\d+)?)/;
const div = /(\d+(?:\.\d+)?) ?\/ ?(\d+(?:\.\d+)?)/;
const add = /(\d+(?:\.\d+)?) ?\+ ?(\d+(?:\.\d+)?)/;
const sub = /(\d+(?:\.\d+)?) ?- ?(\d+(?:\.\d+)?)/;
function evaluate(expr) {
  if (isNaN(Number(expr))) {
    if (parens.test(expr)) {
      const newExpr = expr.replace(parens, (match, subExpr) => String(evaluate(subExpr)));
      return evaluate(newExpr);
    } else if (exp.test(expr)) {
      const newExpr = expr.replace(exp, (match, base, pow) => String(Math.pow(Number(base), Number(pow))));
      return evaluate(newExpr);
    } else if (mul.test(expr)) {
      const newExpr = expr.replace(mul, (match, a, b) => String(Number(a) * Number(b)));
      return evaluate(newExpr);
    } else if (div.test(expr)) {
      const newExpr = expr.replace(div, (match, a, b) => {
        if (b != 0) return String(Number(a) / Number(b));else throw new Error('Division by zero');
      });
      return evaluate(newExpr);
    } else if (add.test(expr)) {
      const newExpr = expr.replace(add, (match, a, b) => String(Number(a) + Number(b)));
      return evaluate(newExpr);
    } else if (sub.test(expr)) {
      const newExpr = expr.replace(sub, (match, a, b) => String(Number(a) - Number(b)));
      return evaluate(newExpr);
    } else {
      return Number(expr);
    }
  }

  return Number(expr);
}

function pick(object, keys) {
  return keys.reduce((obj, key) => {
    if (object && object.hasOwnProperty(key)) {
      obj[key] = object[key];
    }

    return obj;
  }, {});
}
function omit(object, keys) {
  const obj = _objectSpread2({}, object);

  keys.forEach(k => k in object && delete obj[k]);
  return obj;
}
function mapArrayToKeys(value, keys) {
  return value.reduce((acc, v, i) => Object.assign(acc, {
    [keys[i]]: v
  }), {});
}

let SpecialInputTypes;

(function (SpecialInputTypes) {
  SpecialInputTypes["BUTTON"] = "BUTTON";
  SpecialInputTypes["BUTTON_GROUP"] = "BUTTON_GROUP";
  SpecialInputTypes["MONITOR"] = "MONITOR";
  SpecialInputTypes["FOLDER"] = "FOLDER";
})(SpecialInputTypes || (SpecialInputTypes = {}));

function normalizeInput(input, path) {
  if (typeof input === 'object') {
    if ('type' in input) {
      if (input.type in SpecialInputTypes) return input;

      const {
        type: _type
      } = input,
            rest = _objectWithoutProperties(input, ["type"]);

      return _objectSpread2({
        type: _type
      }, normalize$1(_type, rest));
    }

    const _type2 = getValueType(input);

    if (_type2) return _objectSpread2({
      type: _type2
    }, normalize$1(_type2, input));
  }

  const type = getValueType({
    value: input
  });
  if (!type) return warn(LevaErrors.UNKNOWN_INPUT, path, input);
  return _objectSpread2({
    type
  }, normalize$1(type, {
    value: input
  }));
}
function updateInput(input, newValue) {
  const {
    value,
    type,
    settings
  } = input;
  input.value = sanitizeValue({
    type,
    value,
    settings
  }, newValue);
}

const ValueError = function ValueError(message, value, error) {
  this.message = 'LEVA: ' + message;
  this.previousValue = value;
  this.error = error;
};

function sanitizeValue({
  type,
  value,
  settings
}, newValue) {
  const _newValue = typeof newValue === 'function' ? newValue(value) : newValue;

  let sanitizedNewValue;

  try {
    sanitizedNewValue = sanitize$1(type, _newValue, settings, value);
  } catch (e) {
    throw new ValueError(`The value \`${newValue}\` did not result in a correct value.`, value, e);
  }

  if (dequal(sanitizedNewValue, value)) {
    throw new ValueError(`The value \`${newValue}\` did not result in a value update, which remained the same: \`${value}\`.
        You can ignore this warning if this is the intended behavior.`, value);
  }

  return sanitizedNewValue;
}

const debounce = (callback, wait, immediate = false) => {
  let timeout = 0;
  return function () {
    const args = arguments;
    const callNow = immediate && !timeout;

    const next = () => callback.apply(this, args);

    window.clearTimeout(timeout);
    timeout = window.setTimeout(next, wait);
    if (callNow) next();
  };
};

const schema = o => typeof o === 'number' || typeof o === 'string' && !isNaN(parseFloat(o));
const sanitize = (v, {
  min: _min = -Infinity,
  max: _max = Infinity,
  suffix
}) => {
  const _v = parseFloat(v);

  if (v === '' || isNaN(_v)) throw Error('Invalid number');
  const f = clamp(_v, _min, _max);
  return suffix ? f + suffix : f;
};
const format = (v, {
  pad: _pad = 0,
  suffix
}) => {
  const f = parseFloat(v).toFixed(_pad);
  return suffix ? f + suffix : f;
};
const normalize = (_ref) => {
  let {
    value
  } = _ref,
      settings = _objectWithoutProperties(_ref, ["value"]);

  const {
    min,
    max
  } = settings;

  const _value = parseFloat(value);

  let suffix;

  if (!Number.isFinite(value)) {
    const match = String(value).match(/[A-Z]+/i);
    if (match) suffix = match[0];
  }

  let step = settings.step;

  if (!step) {
    if (Number.isFinite(min)) {
      if (Number.isFinite(max)) step = +(Math.abs(max - min) / 100).toPrecision(1);else step = +(Math.abs(_value - min) / 100).toPrecision(1);
    } else if (Number.isFinite(max)) step = +(Math.abs(max - _value) / 100).toPrecision(1);
  }

  const padStep = step ? getStep(step) * 10 : getStep(_value);
  step = step || padStep / 10;
  const pad = Math.round(clamp(Math.log10(1 / padStep), 0, 2));
  return {
    value,
    settings: _objectSpread2({
      initialValue: _value,
      step,
      pad,
      min: -Infinity,
      max: Infinity,
      suffix
    }, settings)
  };
};
const sanitizeStep$1 = (v, {
  step,
  initialValue
}) => {
  const steps = ceil((v - initialValue) / step);
  return initialValue + steps * step;
};

var props = /*#__PURE__*/Object.freeze({
  __proto__: null,
  schema: schema,
  sanitize: sanitize,
  format: format,
  normalize: normalize,
  sanitizeStep: sanitizeStep$1
});

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const InputContext = createContext({});
function useInputContext() {
  return useContext(InputContext);
}
const ThemeContext = createContext(null);
const StoreContext = createContext(null);
const PanelSettingsContext = createContext(null);
function useStoreContext() {
  return useContext(StoreContext);
}
function usePanelSettingsContext() {
  return useContext(PanelSettingsContext);
}
function LevaStoreProvider({
  children,
  store
}) {
  return React.createElement(StoreContext.Provider, {
    value: store
  }, children);
}

const getDefaultTheme = () => ({
  colors: {
    leva__elevation1: '#292d39',
    leva__elevation2: '#181c20',
    leva__elevation3: '#373c4b',
    leva__accent1: '#0066dc',
    leva__accent2: '#007bff',
    leva__accent3: '#3c93ff',
    leva__highlight1: '#535760',
    leva__highlight2: '#8c92a4',
    leva__highlight3: '#fefefe',
    leva__toolTipBackground: '$leva__highlight3',
    leva__toolTipText: '$leva__elevation2'
  },
  radii: {
    leva__xs: '2px',
    leva__sm: '3px',
    leva__lg: '10px'
  },
  space: {
    leva__xs: '3px',
    leva__sm: '6px',
    leva__md: '10px',
    leva__rowGap: '7px',
    leva__colGap: '7px'
  },
  fonts: {
    leva__mono: `ui-monospace, SFMono-Regular, Menlo, 'Roboto Mono', monospace`,
    leva__sans: `system-ui, sans-serif`
  },
  fontSizes: {
    leva__root: '11px',
    leva__toolTip: '$leva__root'
  },
  sizes: {
    leva__rootWidth: '280px',
    leva__controlWidth: '160px',
    leva__numberInputMinWidth: '36px',
    leva__scrubberWidth: '8px',
    leva__scrubberHeight: '16px',
    leva__rowHeight: '24px',
    leva__folderTitleHeight: '20px',
    leva__checkboxSize: '16px',
    leva__joystickWidth: '100px',
    leva__joystickHeight: '100px',
    leva__colorPickerWidth: '$leva__controlWidth',
    leva__colorPickerHeight: '100px',
    leva__imagePreviewWidth: '$leva__controlWidth',
    leva__imagePreviewHeight: '100px',
    leva__monitorHeight: '60px',
    leva__titleBarHeight: '39px'
  },
  shadows: {
    leva__level1: '0 0 9px 0 #00000088',
    leva__level2: '0 4px 14px #00000033'
  },
  borderWidths: {
    leva__root: '0px',
    leva__input: '1px',
    leva__focus: '1px',
    leva__hover: '1px',
    leva__active: '1px',
    leva__folder: '1px'
  },
  fontWeights: {
    leva__label: 'normal',
    leva__folder: 'normal',
    leva__button: 'normal'
  }
});

function createStateClass(value, options) {
  const [borderColor, bgColor] = value.split(' ');
  const css = {};

  if (borderColor !== 'none') {
    css.boxShadow = `${options.inset ? 'inset ' : ''}0 0 0 $borderWidths${[options.key]} $colors${borderColor !== 'default' && borderColor || options.borderColor}`;
  }

  if (bgColor) {
    css.backgroundColor = bgColor || options.backgroundColor;
  }

  return css;
}

const utils = {
  $leva__inputStyle: () => value => createStateClass(value, {
    key: '$leva__input',
    borderColor: '$leva__highlight1',
    inset: true
  }),
  $leva__focusStyle: () => value => createStateClass(value, {
    key: '$leva__focus',
    borderColor: '$leva__accent2'
  }),
  $leva__hoverStyle: () => value => createStateClass(value, {
    key: '$leva__hover',
    borderColor: '$leva__accent1',
    inset: true
  }),
  $leva__activeStyle: () => value => createStateClass(value, {
    key: '$leva__active',
    borderColor: '$leva__accent1',
    inset: true
  })
};
const {
  styled,
  css,
  theme,
  global: _global
} = createCss({
  insertMethod() {
    let currentCssHead = null;
    let currentCssNode = null;
    return cssText => {
      if (typeof document === 'object') {
        if (!currentCssHead) currentCssHead = document.head || document.documentElement;
        if (!currentCssNode) currentCssNode = document.getElementById('leva__stitches') || Object.assign(document.createElement('style'), {
          id: 'leva__stitches'
        });
        if (!currentCssNode.parentNode) currentCssHead.append(currentCssNode);
        currentCssNode.textContent = cssText;
      }
    };
  },

  theme: getDefaultTheme(),
  utils: _objectSpread2(_objectSpread2({}, utils), {}, {
    $leva__flex: () => () => ({
      display: 'flex',
      alignItems: 'center'
    }),
    $leva__flexCenter: () => () => ({
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    }),
    $leva__reset: () => () => ({
      outline: 'none',
      fontSize: 'inherit',
      fontWeight: 'inherit',
      color: 'inherit',
      fontFamily: 'inherit',
      border: 'none',
      backgroundColor: 'transparent',
      WebkitAppearance: 'none',
      appearance: 'none'
    }),
    $leva__draggable: () => () => ({
      touchAction: 'none',
      WebkitUserDrag: 'none',
      userSelect: 'none'
    }),
    $leva__focus: () => value => ({
      '&:focus': utils.$leva__focusStyle()(value)
    }),
    $leva__focusWithin: () => value => ({
      '&:focus-within': utils.$leva__focusStyle()(value)
    }),
    $leva__hover: () => value => ({
      '&:hover': utils.$leva__hoverStyle()(value)
    }),
    $leva__active: () => value => ({
      '&:active': utils.$leva__activeStyle()(value)
    })
  })
});

const globalStyles = _global({
  '.leva__panel__dragged': {
    WebkitUserSelect: 'none',
    WebkitUserDrag: 'none',
    userSelect: 'none',
    input: {
      userSelect: 'none',
      WebkitUserSelect: 'none'
    },
    '*': {
      cursor: 'ew-resize !important'
    }
  }
});

globalStyles();

function mergeTheme(newTheme) {
  const defaultTheme = getDefaultTheme();
  if (!newTheme) return {
    theme: defaultTheme,
    className: ''
  };
  Object.keys(newTheme).forEach(key => {
    Object.assign(defaultTheme[key], newTheme[key]);
  });
  const className = theme(newTheme).className;
  return {
    theme: defaultTheme,
    className
  };
}
function useTh(category, key) {
  const {
    theme
  } = useContext(ThemeContext);

  if (!(category in theme) || !(key in theme[category])) {
    warn(LevaErrors.THEME_ERROR, category, key);
    return '';
  }

  return theme[category][key];
}

const StyledInput = styled('input', {
  $leva__reset: '',
  padding: '0 $leva__sm',
  width: 0,
  minWidth: 0,
  height: '$leva__rowHeight',
  flex: 1,
  variants: {
    levaType: {
      number: {
        textAlign: 'right',
        paddingLeft: '$leva__xs'
      }
    }
  }
});
const InnerLabel = styled('div', {
  height: '100%',
  '& > :first-of-type': {
    $leva__flexCenter: '',
    width: 14,
    height: '100%',
    marginRight: '-$leva__sm',
    textTransform: 'uppercase',
    fontSize: '0.8em',
    opacity: 0.3,
    '&:hover': {
      opacity: 0.8
    }
  },
  [`& + ${StyledInput}`]: {
    paddingLeft: 0
  }
});
const InputContainer = styled('div', {
  $leva__flex: '',
  borderRadius: '$leva__sm',
  color: 'inherit',
  backgroundColor: '$leva__elevation3',
  $leva__inputStyle: '$leva__elevation1',
  $leva__hover: '',
  $leva__focusWithin: ''
});

function ValueInput(_ref) {
  let {
    children,
    value,
    onUpdate,
    onChange,
    onKeyDown,
    type,
    id
  } = _ref,
      props = _objectWithoutProperties(_ref, ["children", "value", "onUpdate", "onChange", "onKeyDown", "type", "id"]);

  const {
    id: _id
  } = useInputContext();
  const inputId = id || _id;
  const update = useCallback(fn => event => {
    const _value = event.currentTarget.value;
    fn(_value);
  }, []);
  const onKeyPress = useCallback(e => {
    if (e.key === 'Enter') {
      update(onUpdate)(e);
    }
  }, [update, onUpdate]);
  return React.createElement(InputContainer, null, children && React.createElement(InnerLabel, null, children), React.createElement(StyledInput, _extends({
    levaType: type,
    id: inputId,
    type: "text",
    spellCheck: "false",
    value: value,
    onChange: update(onChange),
    onBlur: update(onUpdate),
    onKeyPress: onKeyPress,
    onKeyDown: onKeyDown
  }, props)));
}
function NumberInput({
  children,
  id,
  value,
  onUpdate,
  onChange
}) {
  const _onUpdate = useCallback(v => onUpdate(parseNumber(v)), [onUpdate]);

  const onKeyDown = useCallback(event => {
    const dir = event.key === 'ArrowUp' ? 1 : event.key === 'ArrowDown' ? -1 : 0;

    if (dir) {
      event.preventDefault();
      const step = event.altKey ? 0.1 : event.shiftKey ? 10 : 1;
      onUpdate(v => parseFloat(v) + dir * step);
    }
  }, [onUpdate]);
  return React.createElement(ValueInput, {
    id: id,
    value: value,
    onUpdate: _onUpdate,
    onChange: onChange,
    onKeyDown: onKeyDown,
    type: "number"
  }, children);
}

const StyledFolder = styled('div', {});
const StyledWrapper = styled('div', {
  position: 'relative',
  background: '$leva__elevation2',
  transition: 'height 300ms ease',
  variants: {
    fill: {
      true: {},
      false: {}
    },
    flat: {
      false: {},
      true: {}
    },
    isRoot: {
      true: {},
      false: {
        paddingLeft: '$leva__md',
        '&::after': {
          content: '""',
          position: 'absolute',
          left: 0,
          top: 0,
          width: '$borderWidths$leva__folder',
          height: '100%',
          backgroundColor: '$leva__elevation3',
          transform: 'translateX(-50%)'
        }
      }
    }
  },
  compoundVariants: [{
    isRoot: true,
    fill: false,
    css: {
      overflowY: 'auto',
      maxHeight: 'calc(100vh - 20px - $$titleBarHeight)'
    }
  }, {
    isRoot: true,
    flat: false,
    css: {
      borderRadius: '$leva__lg'
    }
  }]
});
const StyledTitle = styled('div', {
  $leva__flex: '',
  color: '$leva__highlight3',
  WebkitUserSelect: 'none',
  userSelect: 'none',
  cursor: 'pointer',
  height: '$leva__folderTitleHeight',
  fontWeight: '$leva__folder',
  '> svg': {
    marginLeft: -4,
    marginRight: 4,
    cursor: 'pointer',
    fill: '$leva__highlight1'
  },
  '&:hover > svg': {
    fill: '$leva__highlight2'
  },
  [`&:hover + ${StyledWrapper}::after`]: {
    backgroundColor: '$leva__highlight2'
  },
  [`${StyledFolder}:hover > & + ${StyledWrapper}::after`]: {
    backgroundColor: '$leva__highlight1'
  },
  [`${StyledFolder}:hover > & > svg`]: {
    fill: '$leva__highlight1'
  }
});
const StyledContent = styled('div', {
  position: 'relative',
  display: 'grid',
  gridTemplateColumns: '100%',
  rowGap: '$leva__rowGap',
  transition: 'opacity 250ms ease',
  variants: {
    toggled: {
      true: {
        opacity: 1,
        transitionDelay: '250ms'
      },
      false: {
        opacity: 0,
        transitionDelay: '0ms',
        pointerEvents: 'none'
      }
    },
    isRoot: {
      true: {
        '& > div': {
          paddingLeft: '$leva__md',
          paddingRight: '$leva__md'
        },
        '& > div:first-of-type': {
          paddingTop: '$leva__sm'
        },
        '& > div:last-of-type': {
          paddingBottom: '$leva__sm'
        },
        [`> ${StyledFolder}:not(:first-of-type)`]: {
          paddingTop: '$leva__sm',
          marginTop: '$leva__md',
          borderTop: '$borderWidths$leva__folder solid $colors$leva__elevation1'
        }
      }
    }
  }
});

const StyledRow = styled('div', {
  position: 'relative',
  display: 'grid',
  rowGap: '$leva__rowGap',
  gridTemplateRows: 'minmax($sizes$leva__rowHeight, max-content)',
  alignItems: 'center',
  color: '$leva__highlight2',
  [`${StyledContent} > &`]: {
    '&:first-of-type': {
      marginTop: '$leva__rowGap'
    },
    '&:last-of-type': {
      marginBottom: '$leva__rowGap'
    }
  },
  '&:hover,&:focus-within': {
    color: '$leva__highlight3'
  }
});
const StyledInputRow = styled(StyledRow, {
  gridTemplateColumns: 'auto $sizes$leva__controlWidth',
  columnGap: '$leva__colGap'
});
const CopyLabelContainer = styled('div', {
  $leva__flex: '',
  height: '100%',
  position: 'relative',
  overflow: 'hidden',
  '& > div': {
    marginLeft: '$leva__colGap',
    padding: '0 $xs',
    opacity: 0.4
  },
  '& > div:hover': {
    opacity: 0.8
  },
  '& > div > svg': {
    display: 'none',
    cursor: 'pointer',
    width: 13,
    minWidth: 13,
    height: 13,
    backgroundColor: '$leva__elevation2'
  },
  '&:hover > div > svg': {
    display: 'block'
  }
});
const StyledOptionalToggle = styled('input', {
  $leva__reset: '',
  height: 0,
  width: 0,
  opacity: 0,
  margin: 0,
  '& + label': {
    position: 'relative',
    $leva__flexCenter: '',
    height: '100%',
    WebkitUserSelect: 'none',
    userSelect: 'none',
    cursor: 'pointer',
    paddingLeft: 2,
    paddingRight: '$leva__sm',
    pointerEvents: 'auto'
  },
  '& + label:after': {
    content: '""',
    width: 6,
    height: 6,
    backgroundColor: '$leva__elevation3',
    borderRadius: '50%',
    $leva__activeStyle: ''
  },
  '&:focus + label:after': {
    $leva__focusStyle: ''
  },
  '& + label:active:after': {
    backgroundColor: '$leva__accent1',
    $leva__focusStyle: ''
  },
  '&:checked + label:after': {
    backgroundColor: '$leva__accent1'
  }
});
const StyledInputWrapper = styled('div', {
  opacity: 1,
  variants: {
    disabled: {
      true: {
        opacity: 0.6,
        pointerEvents: 'none'
      }
    }
  }
});
const StyledLabel = styled('label', {
  fontWeight: '$leva__label',
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  whiteSpace: 'nowrap',
  '& > svg': {
    display: 'block'
  },
  variants: {
    align: {
      top: {
        height: '100%',
        alignItems: 'flex-start',
        paddingTop: '$leva__sm'
      }
    }
  }
});
const Overlay = styled('div', {
  position: 'fixed',
  top: 0,
  bottom: 0,
  right: 0,
  left: 0,
  zIndex: 1000
});
const StyledToolTipContent = styled('div', {
  background: '$leva__toolTipBackground',
  fontFamily: '$leva__sans',
  fontSize: '$leva__toolTip',
  padding: '$leva__xs $leva__sm',
  color: '$leva__toolTipText',
  borderRadius: '$leva__xs',
  boxShadow: '$leva__level2'
});
const ToolTipArrow = styled(Arrow, {
  fill: '$leva__toolTipBackground'
});

function Portal({
  children
}) {
  const {
    className
  } = useContext(ThemeContext);
  return React.createElement(Root, {
    className: className
  }, children);
}

function OptionalToggle() {
  const {
    id,
    disable,
    disabled
  } = useInputContext();
  return React.createElement(React.Fragment, null, React.createElement(StyledOptionalToggle, {
    id: id + '__disable',
    type: "checkbox",
    checked: !disabled,
    onChange: () => disable(!disabled)
  }), React.createElement("label", {
    htmlFor: id + '__disable'
  }));
}

function RawLabel(props) {
  const {
    id,
    optional,
    hint
  } = useInputContext();
  const htmlFor = props.htmlFor || (id ? {
    htmlFor: id
  } : null);
  return React.createElement(React.Fragment, null, optional && React.createElement(OptionalToggle, null), hint !== undefined ? React.createElement(Root$1, null, React.createElement(Trigger, _extends({
    as: StyledLabel
  }, htmlFor, props)), React.createElement(Content, {
    side: "top",
    sideOffset: 2
  }, React.createElement(StyledToolTipContent, null, hint, React.createElement(ToolTipArrow, null)))) : React.createElement(StyledLabel, _extends({}, htmlFor, props)));
}

function LabelWithCopy(props) {
  const {
    value,
    label,
    key
  } = useInputContext();
  const [copied, setCopied] = useState(false);

  const handleClick = async () => {
    try {
      await writeText(JSON.stringify({
        [key]: value !== null && value !== void 0 ? value : ''
      }));
      setCopied(true);
    } catch (_unused) {
      warn(LevaErrors.CLIPBOARD_ERROR, {
        [key]: value
      });
    }
  };

  return React.createElement(CopyLabelContainer, {
    onPointerLeave: () => setCopied(false)
  }, React.createElement(RawLabel, props), React.createElement("div", {
    title: `Click to copy ${typeof label === 'string' ? label : key} value`
  }, !copied ? React.createElement("svg", {
    onClick: handleClick,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, React.createElement("path", {
    d: "M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"
  }), React.createElement("path", {
    d: "M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"
  })) : React.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, React.createElement("path", {
    d: "M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"
  }), React.createElement("path", {
    fillRule: "evenodd",
    d: "M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm9.707 5.707a1 1 0 00-1.414-1.414L9 12.586l-1.293-1.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",
    clipRule: "evenodd"
  }))));
}

function Label(props) {
  const {
    key
  } = useInputContext();
  const {
    hideCopyButton
  } = usePanelSettingsContext();
  const copyClipboard = key !== undefined;
  return copyClipboard && !hideCopyButton ? React.createElement(LabelWithCopy, props) : React.createElement(RawLabel, props);
}

const Svg = styled('svg', {
  fill: 'currentColor',
  transition: 'transform 350ms ease, fill 250ms ease'
});
function Chevron(_ref) {
  let {
    toggled
  } = _ref,
      props = _objectWithoutProperties(_ref, ["toggled"]);

  return React.createElement(Svg, _extends({
    width: "9",
    height: "5",
    viewBox: "0 0 9 5",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
      transform: `rotate(${toggled ? 0 : -90}deg)`
    }
  }, props), React.createElement("path", {
    d: "M3.8 4.4c.4.3 1 .3 1.4 0L8 1.7A1 1 0 007.4 0H1.6a1 1 0 00-.7 1.7l3 2.7z"
  }));
}

function Row(_ref) {
  let {
    input
  } = _ref,
      props = _objectWithoutProperties(_ref, ["input"]);

  if (input) return React.createElement(StyledInputRow, props);
  return React.createElement(StyledRow, props);
}

function useValue({
  value,
  type,
  settings,
  setValue
}) {
  const [displayValue, setDisplayValue] = useState(format$1(type, value, settings));
  const previousValueRef = useRef(value);
  const setFormat = useCallback(v => setDisplayValue(format$1(type, v, settings)), [type, settings]);
  const onUpdate = useCallback(updatedValue => {
    try {
      setValue(updatedValue);
    } catch ({
      previousValue
    }) {
      setFormat(previousValue);
    }
  }, [setFormat, setValue]);
  useEffect(() => {
    if (!dequal(value, previousValueRef.current)) {
      setFormat(value);
    }

    previousValueRef.current = value;
  }, [value, setFormat]);
  return {
    displayValue,
    onChange: setDisplayValue,
    onUpdate
  };
}

function useDrag(handler, config) {
  return useDrag$1(state => {
    if (state.first) document.body.classList.add('leva__panel__dragged');else if (state.last) document.body.classList.remove('leva__panel__dragged');
    return handler(state);
  }, config);
}

const multiplyStep = event => event.shiftKey ? 5 : event.altKey ? 1 / 5 : 1;
function useDragNumber({
  settings,
  onDrag
}) {
  const {
    step
  } = settings;
  return useDrag(({
    delta: [dx],
    event,
    memo: _memo = 0
  }) => {
    _memo += dx / 2;

    if (Math.abs(_memo) >= 1) {
      onDrag(v => parseFloat(v) + Math.floor(_memo) * step * multiplyStep(event));
      _memo = 0;
    }

    return _memo;
  });
}

function useCanvas2d(fn) {
  const canvas = useRef(null);
  const ctx = useRef(null);
  useEffect(() => {
    const handleCanvas = debounce(() => {
      canvas.current.width = canvas.current.offsetWidth * window.devicePixelRatio;
      canvas.current.height = canvas.current.offsetHeight * window.devicePixelRatio;
      fn(canvas.current, ctx.current);
    }, 250);
    window.addEventListener('resize', handleCanvas);
    handleCanvas();
    return () => window.removeEventListener('resize', handleCanvas);
  }, [fn]);
  useEffect(() => {
    ctx.current = canvas.current.getContext('2d');
  }, []);
  return [canvas, ctx];
}

function useTransform() {
  const ref = useRef(null);
  const local = useRef({
    x: 0,
    y: 0
  });
  const set = useCallback(point => {
    Object.assign(local.current, point);
    if (ref.current) ref.current.style.transform = `translate3d(${local.current.x}px, ${local.current.y}px, 0)`;
  }, []);
  return [ref, set];
}

const getInputAtPath = (data, path) => {
  if (!data[path]) return null;

  const _data$path = data[path],
        input = _objectWithoutProperties(_data$path, ["__refCount"]);

  return input;
};

function useInput(path) {
  const store = useStoreContext();
  const [state, setState] = useState(getInputAtPath(store.getData(), path));
  const set = useCallback(value => store.setValueAtPath(path, value), [path, store]);
  const setSettings = useCallback(settings => store.setSettingsAtPath(path, settings), [path, store]);
  const disable = useCallback(flag => store.disableInputAtPath(path, flag), [path, store]);
  useEffect(() => {
    setState(getInputAtPath(store.getData(), path));
    const unsub = store.useStore.subscribe(setState, s => getInputAtPath(s.data, path), shallow);
    return () => unsub();
  }, [store, path]);
  return [state, {
    set,
    setSettings,
    disable
  }];
}

const InnerNumberLabel = styled('div', {
  $leva__draggable: '',
  cursor: 'ew-resize'
});
const RangeGrid = styled('div', {
  variants: {
    hasRange: {
      true: {
        position: 'relative',
        display: 'grid',
        gridTemplateColumns: 'auto $sizes$leva__numberInputMinWidth',
        columnGap: '$leva__colGap',
        alignItems: 'center'
      }
    }
  }
});

const Range = styled('div', {
  position: 'relative',
  width: '100%',
  height: 2,
  borderRadius: '$leva__xs',
  backgroundColor: '$leva__elevation1'
});
const Scrubber = styled('div', {
  position: 'absolute',
  width: '$leva__scrubberWidth',
  height: '$leva__scrubberHeight',
  borderRadius: '$leva__xs',
  boxShadow: '0 0 0 2px $leva__elevation2',
  backgroundColor: '$leva__accent2',
  cursor: 'pointer',
  $leva__active: 'none $leva__accent1',
  $leva__hover: 'none $leva__accent3',
  variants: {
    position: {
      left: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0,
        transform: 'translateX(calc(-0.5 * ($sizes$leva__scrubberWidth + 4px)))'
      },
      right: {
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0,
        transform: 'translateX(calc(0.5 * ($sizes$leva__scrubberWidth + 4px)))'
      }
    }
  }
});
const RangeWrapper = styled('div', {
  position: 'relative',
  $leva__flex: '',
  height: '100%',
  cursor: 'pointer',
  touchAction: 'none'
});
const Indicator = styled('div', {
  position: 'absolute',
  height: '100%',
  backgroundColor: '$leva__accent2'
});

function RangeSlider({
  value,
  min,
  max,
  onDrag,
  step,
  initialValue
}) {
  const ref = useRef(null);
  const scrubberRef = useRef(null);
  const rangeWidth = useRef(0);
  const scrubberWidth = useTh('sizes', 'leva__scrubberWidth');
  const bind = useDrag(({
    event,
    first,
    xy: [x],
    movement: [mx],
    memo
  }) => {
    if (first) {
      const {
        width,
        left
      } = ref.current.getBoundingClientRect();
      rangeWidth.current = width - parseFloat(scrubberWidth);
      const targetIsScrub = (event === null || event === void 0 ? void 0 : event.target) === scrubberRef.current;
      memo = targetIsScrub ? value : invertedRange((x - left) / width, min, max);
    }

    const newValue = memo + invertedRange(mx / rangeWidth.current, 0, max - min);
    onDrag(sanitizeStep$1(newValue, {
      step,
      initialValue
    }));
    return memo;
  });
  const pos = range(value, min, max);
  return React.createElement(RangeWrapper, _extends({
    ref: ref
  }, bind()), React.createElement(Range, null, React.createElement(Indicator, {
    style: {
      left: 0,
      right: `calc(${1 - pos} * (100% - ${scrubberWidth}))`
    }
  })), React.createElement(Scrubber, {
    ref: scrubberRef,
    style: {
      left: `calc(${pos} * (100% - ${scrubberWidth}))`
    }
  }));
}

function Number$1({
  label,
  id,
  displayValue,
  onUpdate,
  onChange,
  settings,
  hideLabel = false
}) {
  const bind = useDragNumber({
    settings,
    onDrag: onUpdate
  });
  return React.createElement(NumberInput, {
    id: id,
    value: displayValue,
    onUpdate: onUpdate,
    onChange: onChange
  }, !hideLabel && React.createElement(InnerNumberLabel, _extends({
    title: label.length > 1 ? label : ''
  }, bind()), label.charAt(0)));
}
function NumberComponent() {
  const props = useInputContext();
  const {
    label,
    value,
    onUpdate,
    settings,
    id
  } = props;
  const {
    min,
    max
  } = settings;
  const hasRange = max !== Infinity && min !== -Infinity;
  return React.createElement(Row, {
    input: true
  }, React.createElement(Label, null, label), React.createElement(RangeGrid, {
    hasRange: hasRange
  }, hasRange && React.createElement(RangeSlider, _extends({
    value: parseFloat(value),
    onDrag: onUpdate
  }, settings)), React.createElement(Number$1, _extends({}, props, {
    id: id,
    label: "value",
    hideLabel: hasRange
  }))));
}

const {
  sanitizeStep
} = props,
      rest = _objectWithoutProperties(props, ["sanitizeStep"]);
var number = createInternalPlugin(_objectSpread2({
  component: NumberComponent
}, rest));

function Coordinate({
  value,
  id,
  valueKey,
  settings,
  onUpdate,
  hideLabel
}) {
  const args = {
    type: 'NUMBER',
    value: value[valueKey],
    settings
  };

  const setValue = newValue => onUpdate({
    [valueKey]: sanitizeValue(args, newValue)
  });

  const number = useValue(_objectSpread2(_objectSpread2({}, args), {}, {
    setValue
  }));
  return React.createElement(Number$1, {
    id: id,
    label: valueKey,
    value: value[valueKey],
    displayValue: number.displayValue,
    onUpdate: number.onUpdate,
    onChange: number.onChange,
    settings: settings,
    hideLabel: hideLabel
  });
}

const Container = styled('div', {
  display: 'grid',
  columnGap: '$leva__colGap',
  gridAutoFlow: 'column dense',
  alignItems: 'center',
  variants: {
    withLock: {
      true: {
        gridTemplateColumns: '10px auto',
        '> svg': {
          cursor: 'pointer'
        }
      }
    }
  }
});

function Lock(_ref) {
  let {
    locked
  } = _ref,
      props = _objectWithoutProperties(_ref, ["locked"]);

  return React.createElement("svg", _extends({
    width: "10",
    height: "10",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), locked ? React.createElement("path", {
    d: "M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }) : React.createElement("path", {
    d: "M9 3.63601C9 2.76044 9.24207 2.11211 9.64154 1.68623C10.0366 1.26502 10.6432 1 11.5014 1C12.4485 1 13.0839 1.30552 13.4722 1.80636C13.8031 2.23312 14 2.84313 14 3.63325H15C15 2.68242 14.7626 1.83856 14.2625 1.19361C13.6389 0.38943 12.6743 0 11.5014 0C10.4294 0 9.53523 0.337871 8.91218 1.0021C8.29351 1.66167 8 2.58135 8 3.63601V6H1C0.447715 6 0 6.44772 0 7V13C0 13.5523 0.447715 14 1 14H10C10.5523 14 11 13.5523 11 13V7C11 6.44772 10.5523 6 10 6H9V3.63601ZM1 7H10V13H1V7Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}

function Vector({
  value,
  onUpdate,
  settings,
  hideNumberLabels
}) {
  const {
    id,
    setSettings
  } = useInputContext();
  const {
    lock,
    locked
  } = settings;
  return React.createElement(Container, {
    withLock: lock
  }, lock && React.createElement(Lock, {
    locked: locked,
    onClick: () => setSettings({
      locked: !locked
    })
  }), Object.keys(value).map((key, i) => React.createElement(Coordinate, {
    id: i === 0 ? id : `${id}.${key}`,
    key: key,
    valueKey: key,
    value: value,
    settings: settings[key],
    onUpdate: onUpdate,
    hideLabel: hideNumberLabels
  })));
}

const normalizeKeyedNumberSettings = (value, settings) => {
  const _settings = {};
  let maxStep = 0;
  let minPad = Infinity;
  Object.entries(value).forEach(([key, v]) => {
    _settings[key] = normalize(_objectSpread2({
      value: v
    }, settings[key])).settings;
    maxStep = Math.max(maxStep, _settings[key].step);
    minPad = Math.min(minPad, _settings[key].pad);
  });

  for (let key in _settings) {
    const {
      step,
      min,
      max
    } = settings[key] || {};

    if (!isFinite(step) && (!isFinite(min) || !isFinite(max))) {
      _settings[key].step = maxStep;
      _settings[key].pad = minPad;
    }
  }

  return _settings;
};

function getVectorSchema(dimension) {
  const isVectorArray = v8n().array().length(dimension).every.number();

  const isVectorObject = o => {
    if (!o || typeof o !== 'object') return false;
    const values = Object.values(o);
    return values.length === dimension && values.every(v => isFinite(v));
  };

  return o => {
    return isVectorArray.test(o) || isVectorObject(o);
  };
}
function getVectorType(value) {
  return Array.isArray(value) ? 'array' : 'object';
}

function convert(value, format, keys) {
  if (getVectorType(value) === format) return value;
  return format === 'array' ? Object.values(value) : mapArrayToKeys(value, keys);
}

const sanitizeVector = (value, settings, previousValue) => {
  const _value = convert(value, 'object', settings.keys);

  for (let key in _value) _value[key] = sanitize(_value[key], settings[key]);

  const _valueKeys = Object.keys(_value);

  let newValue = {};
  if (_valueKeys.length === settings.keys.length) newValue = _value;else {
      const _previousValue = convert(previousValue, 'object', settings.keys);

      if (_valueKeys.length === 1 && settings.locked) {
        const lockedKey = _valueKeys[0];
        const lockedCoordinate = _value[lockedKey];
        const previousLockedCoordinate = _previousValue[lockedKey];
        const ratio = previousLockedCoordinate !== 0 ? lockedCoordinate / previousLockedCoordinate : 1;

        for (let key in _previousValue) {
          if (key === lockedKey) newValue[lockedKey] = lockedCoordinate;else newValue[key] = _previousValue[key] * ratio;
        }
      } else {
        newValue = _objectSpread2(_objectSpread2({}, _previousValue), _value);
      }
    }
  return convert(newValue, settings.format, settings.keys);
};
const formatVector = (value, settings) => convert(value, 'object', settings.keys);

const isNumberSettings = o => !!o && ('step' in o || 'min' in o || 'max' in o);

function normalizeVector(value, settings, defaultKeys = []) {
  const {
    lock = false
  } = settings,
        _settings = _objectWithoutProperties(settings, ["lock"]);

  const format = Array.isArray(value) ? 'array' : 'object';
  const keys = format === 'object' ? Object.keys(value) : defaultKeys;

  const _value = convert(value, 'object', keys);

  const mergedSettings = isNumberSettings(_settings) ? keys.reduce((acc, k) => Object.assign(acc, {
    [k]: _settings
  }), {}) : _settings;
  const numberSettings = normalizeKeyedNumberSettings(_value, mergedSettings);
  return {
    value: format === 'array' ? value : _value,
    settings: _objectSpread2(_objectSpread2({}, numberSettings), {}, {
      format,
      keys,
      lock,
      locked: false
    })
  };
}
function getVectorPlugin(defaultKeys) {
  return {
    schema: getVectorSchema(defaultKeys.length),
    normalize: (_ref) => {
      let {
        value
      } = _ref,
          settings = _objectWithoutProperties(_ref, ["value"]);

      return normalizeVector(value, settings, defaultKeys);
    },
    format: (value, settings) => formatVector(value, settings),
    sanitize: (value, settings, prevValue) => sanitizeVector(value, settings, prevValue)
  };
}

export { number as $, useValue as A, Plugins as B, Chevron as C, log as D, InputContext as E, StyledInputWrapper as F, useCanvas2d as G, useInput as H, Indicator as I, StyledWrapper as J, StyledContent as K, Label as L, useStoreContext as M, StyledFolder as N, Overlay as O, Portal as P, StyledInputRow as Q, Row as R, Scrubber as S, debounce as T, PanelSettingsContext as U, ValueInput as V, StoreContext as W, mergeTheme as X, ThemeContext as Y, register as Z, _objectSpread2 as _, Vector as a, LevaStoreProvider as a0, pad as a1, evaluate as a2, createPlugin as a3, useDragNumber as a4, getVectorSchema as a5, getVectorType as a6, sanitizeVector as a7, formatVector as a8, normalizeVector as a9, useTransform as b, createInternalPlugin as c, useTh as d, _extends as e, clamp as f, getVectorPlugin as g, _objectWithoutProperties as h, useDrag as i, invertedRange as j, sanitizeStep as k, RangeWrapper as l, multiplyStep as m, normalizeKeyedNumberSettings as n, omit as o, pick as p, Range as q, range as r, styled as s, SpecialInputTypes as t, useInputContext as u, LevaErrors as v, warn as w, updateInput as x, normalizeInput as y, StyledTitle as z };
