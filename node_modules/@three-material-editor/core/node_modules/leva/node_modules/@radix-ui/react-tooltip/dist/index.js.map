{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/tooltip/src/machine.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport type StateChart<State extends string, Event extends string, Context> = {\n  initial: State;\n  context: Context;\n  states: Record<State, StateDefinition<State, Event, Context>>;\n};\n\ntype StateDefinition<State, Event extends string, Context> = {\n  onEnterState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  onLeaveState?: (transitionFn: TransitionFn<Event, Context>) => void;\n  on?: { [index in Event]?: State };\n};\n\nexport type TransitionFn<Event, Context> = (event: Event, context?: Context) => void;\n\nexport function createStateMachine<State extends string, Event extends string, Context>(\n  stateChart: StateChart<State, Event, Context>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let PREVIOUS_STATE: State | undefined;\n  let CURRENT_STATE = stateChart.initial;\n  let PREVIOUS_CONTEXT: Context | undefined;\n  let CURRENT_CONTEXT = stateChart.context;\n\n  type CallbackFn = (args: { state: State; previousState?: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) =>\n      callback({\n        state: CURRENT_STATE,\n        previousState: PREVIOUS_STATE,\n        context: CURRENT_CONTEXT,\n      })\n    );\n  }\n\n  const transition: TransitionFn<Event, Context> = (event, context) => {\n    const stateDefinition = stateChart.states[CURRENT_STATE];\n\n    // we cast to `State | undefined` because otherwise the type of `nextState`\n    // would be `{ [index in Event]?: State | undefined; }[Event] | undefined`\n    // and would cause issue later when trying to grab `nextStateDefinition`\n    // as it would conflict with the type of `StateChart.states` which is\n    // `Record<State, StateDefinition<State, Event>>`\n    const nextState: State | undefined = stateDefinition.on && stateDefinition.on[event];\n\n    if (nextState === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(`From state: \"${CURRENT_STATE}\", event \"${event}\" does not lead to any state`);\n      }\n    } else {\n      PREVIOUS_STATE = CURRENT_STATE;\n      PREVIOUS_CONTEXT = CURRENT_CONTEXT;\n\n      if (stateDefinition.onLeaveState) {\n        stateDefinition.onLeaveState(transition);\n      }\n\n      const nextStateDefinition = stateChart.states[nextState];\n\n      if (nextStateDefinition.onEnterState) {\n        nextStateDefinition.onEnterState(transition);\n      }\n\n      CURRENT_STATE = nextState;\n\n      if (context !== undefined) {\n        CURRENT_CONTEXT = context;\n      }\n\n      if (debug) {\n        console.log({\n          previousState: PREVIOUS_STATE,\n          previousContext: PREVIOUS_CONTEXT,\n          event,\n          state: CURRENT_STATE,\n          context: CURRENT_CONTEXT,\n        });\n      }\n\n      notify();\n    }\n  };\n\n  function getState() {\n    return CURRENT_STATE;\n  }\n\n  function getContext() {\n    return CURRENT_CONTEXT;\n  }\n\n  return {\n    subscribe,\n    transition,\n    getState,\n    getContext,\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Core state machine implementation\n * TODO: Consider adopting a state machine lib or reimplementing for broader usage\n * -----------------------------------------------------------------------------------------------*/\n\n// How long the mouse needs to stop moving for the tooltip to open\nconst REST_THRESHOLD_DURATION = 300;\n\n// How much time does the user has to move from one tooltip to another without incurring the rest wait\nconst SKIP_REST_THRESHOLD_DURATION = 300;\n\ntype TooltipState =\n  // tooltip is closed\n  | 'CLOSED'\n\n  // still closed\n  // we are waiting for the mouse to stop moving (REST_THRESHOLD_DURATION)\n  | 'WAITING_FOR_REST'\n\n  // tooltip is open\n  | 'OPEN'\n\n  // tooltip is closed\n  // we are checking if the mouse enters another tooltip trigger (SKIP_REST_THRESHOLD_DURATION)\n  | 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD'\n\n  // tooltip has been dismissed via click or keyboard action (escape, space, enter)\n  | 'DISMISSED';\n\ntype TooltipEvent =\n  | 'mouseEntered'\n  | 'mouseMoved'\n  | 'mouseLeft'\n  | 'restTimerElapsed'\n  | 'skipRestTimerElapsed'\n  | 'focused'\n  | 'blurred'\n  | 'activated'\n  | 'triggerMoved'\n  | 'unmounted';\n\ntype TooltipContext = { id: string | null };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipEvent, TooltipContext>;\ntype TooltipTransitionFn = TransitionFn<TooltipEvent, TooltipContext>;\n\nexport const stateChart: TooltipStateChart = {\n  initial: 'CLOSED',\n  context: { id: null },\n  states: {\n    CLOSED: {\n      on: {\n        mouseEntered: 'WAITING_FOR_REST',\n        focused: 'OPEN',\n      },\n    },\n    WAITING_FOR_REST: {\n      onEnterState: startRestTimer,\n      onLeaveState: clearRestTimer,\n      on: {\n        restTimerElapsed: 'OPEN',\n        mouseMoved: 'WAITING_FOR_REST',\n        mouseLeft: 'CLOSED',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    OPEN: {\n      on: {\n        mouseLeft: 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD',\n        mouseEntered: 'OPEN',\n        mouseMoved: 'OPEN',\n        activated: 'DISMISSED',\n        blurred: 'CLOSED',\n        triggerMoved: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD: {\n      onEnterState: startSkipRestTimer,\n      onLeaveState: clearSkipRestTimer,\n      on: {\n        skipRestTimerElapsed: 'CLOSED',\n        mouseEntered: 'OPEN',\n        focused: 'OPEN',\n        activated: 'DISMISSED',\n        unmounted: 'CLOSED',\n      },\n    },\n    DISMISSED: {\n      on: {\n        mouseLeft: 'CLOSED',\n        blurred: 'CLOSED',\n        unmounted: 'CLOSED',\n      },\n    },\n  },\n};\n\n// The rest timer is used to check for the user \"resting\" a certain\n// period of time over the trigger, before deciding to open the tooltip.\nlet restTimerId: number;\n\nfunction startRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(restTimerId);\n  restTimerId = window.setTimeout(() => transition('restTimerElapsed'), REST_THRESHOLD_DURATION);\n}\n\nfunction clearRestTimer() {\n  clearTimeout(restTimerId);\n}\n\n// The skip rest timer is used to check if the user enters another tooltip trigger\n// in a certain period of time, in which case, we would skip the rest timer and open\n// the tooltip instantly.\nlet skipRestTimerId: number;\n\nfunction startSkipRestTimer(transition: TooltipTransitionFn) {\n  clearTimeout(skipRestTimerId);\n  skipRestTimerId = window.setTimeout(\n    () => transition('skipRestTimerElapsed'),\n    SKIP_REST_THRESHOLD_DURATION\n  );\n}\n\nfunction clearSkipRestTimer() {\n  clearTimeout(skipRestTimerId);\n}\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Primitive, extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine, stateChart } from './machine';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(stateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n};\n\nconst [TooltipProvider, useTooltipContext] = createContext<TooltipContextValue>(TOOLTIP_NAME);\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const { children, open: openProp, defaultOpen = false, onOpenChange } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'OPEN' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, previousState }) => {\n      if (state === 'OPEN') {\n        if (previousState === 'WAITING_FOR_REST') {\n          setStateAttribute('delayed-open');\n        }\n        if (\n          previousState === 'CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD' ||\n          previousState === 'CLOSED'\n        ) {\n          setStateAttribute('instant-open');\n        }\n      }\n      if (state === 'CLOSED') {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, []);\n\n  // send transition if the component unmounts\n  React.useEffect(() => {\n    return () => {\n      stateMachine.transition('unmounted', { id: contentId });\n    };\n  }, [contentId]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.transition('mouseEntered', { id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <TooltipProvider\n      triggerRef={triggerRef}\n      contentId={contentId}\n      open={open}\n      stateAttribute={stateAttribute}\n    >\n      {children}\n    </TooltipProvider>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Polymorphic.OwnProps<typeof Primitive>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const { as = TRIGGER_DEFAULT_TAG, ...triggerProps } = props;\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n\n  return (\n    <Primitive\n      type=\"button\"\n      aria-describedby={context.open ? context.contentId : undefined}\n      data-state={context.stateAttribute}\n      {...triggerProps}\n      as={as}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, () =>\n        stateMachine.transition('mouseEntered', { id: context.contentId })\n      )}\n      onMouseMove={composeEventHandlers(props.onMouseMove, () =>\n        stateMachine.transition('mouseMoved', { id: context.contentId })\n      )}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('mouseLeft', { id: context.contentId });\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () =>\n        stateMachine.transition('focused', { id: context.contentId })\n      )}\n      onBlur={composeEventHandlers(props.onBlur, () => {\n        const stateMachineContext = stateMachine.getContext();\n        if (stateMachineContext.id === context.contentId) {\n          stateMachine.transition('blurred', { id: context.contentId });\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, () =>\n        stateMachine.transition('activated', { id: context.contentId })\n      )}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Escape' || event.key === 'Enter' || event.key === ' ') {\n          stateMachine.transition('activated', { id: context.contentId });\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.OwnProps<typeof TooltipContentImpl>;\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME);\n  return context.open ? <TooltipContentImpl ref={forwardedRef} {...props} /> : null;\n}) as TooltipContentPrimitive;\n\ntype PopperPrimitiveOwnProps = Polymorphic.OwnProps<typeof PopperPrimitive.Root>;\ntype TooltipContentImplOwnProps = Polymorphic.Merge<\n  PopperPrimitiveOwnProps,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    anchorRef?: PopperPrimitiveOwnProps['anchorRef'];\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Root>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, anchorRef, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Root\n        data-state={context.stateAttribute}\n        {...contentProps}\n        ref={forwardedRef}\n        anchorRef={anchorRef || context.triggerRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        <Slottable>{children}</Slottable>\n        <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHiddenPrimitive.Root>\n      </PopperPrimitive.Root>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'TooltipArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const context = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(context.triggerRef);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      stateMachine.transition('triggerMoved', { id: context.contentId });\n    }\n  }, [context.contentId, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\n"],"names":["$parcel$exportWildcard","dest","source","Object","keys","forEach","key","defineProperty","enumerable","get","restTimerId","skipRestTimerId","stateMachine","stateChart","PREVIOUS_STATE","PREVIOUS_CONTEXT","_ref","arguments","length","undefined","_ref$debug","debug","_ref$warnOnUnknownTra","warnOnUnknownTransitions","CURRENT_STATE","initial","CURRENT_CONTEXT","context","subscriptions","subscribe","callback","push","splice","indexOf","notify","state","previousState","transition","event","stateDefinition","states","nextState","on","console","warn","concat","onLeaveState","nextStateDefinition","onEnterState","log","previousContext","getState","getContext","$e635218480c28d9f27af72d31e573b83$export$createStateMachine","id","CLOSED","mouseEntered","focused","WAITING_FOR_REST","clearTimeout","window","setTimeout","restTimerElapsed","mouseMoved","mouseLeft","activated","unmounted","OPEN","blurred","triggerMoved","CHECKING_IF_SHOULD_SKIP_REST_THRESHOLD","skipRestTimerElapsed","DISMISSED","createContext","TooltipProvider","useTooltipContext","Tooltip","props","children","openProp","open","_props$defaultOpen","defaultOpen","onOpenChange","triggerRef","React","useRef","contentId","useId","_useControllableState2","$bfd2ef98f93cfd0786881e49eeb6a4$var$_slicedToArray","useControllableState","prop","defaultProp","onChange","_useControllableState3","setOpen","_React$useState2","useState","stateAttribute","setStateAttribute","useEffect","_ref2","useLayoutEffect","_react","createElement","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipProvider","displayName","TooltipTrigger","forwardRef","forwardedRef","_props$as","as","triggerProps","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectWithoutProperties","composedTriggerRef","useComposedRefs","Primitive","$bfd2ef98f93cfd0786881e49eeb6a4$var$_extends","type","aria-describedby","data-state","ref","onMouseEnter","composeEventHandlers","onMouseMove","onMouseLeave","onFocus","onBlur","onMouseDown","onKeyDown","TooltipContent","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipContentImpl","TooltipContentImpl","ariaLabel","anchorRef","_props$portalled","portalled","contentProps","PortalWrapper","Portal","Fragment","$bfd2ef98f93cfd0786881e49eeb6a4$var$CheckTriggerMoved","_radixUiReactPopper","Root","style","$bfd2ef98f93cfd0786881e49eeb6a4$var$_objectSpread","$bfd2ef98f93cfd0786881e49eeb6a4$var$_defineProperty","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","extendPrimitive","PopperPrimitive","Arrow","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger","Content"],"version":3,"file":"index.js.map"}